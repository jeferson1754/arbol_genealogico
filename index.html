<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>√Årbol Geneal√≥gico Interactivo</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f2f5;
        }
        /* --- ESTILOS MEJORADOS PARA EL √ÅRBOL GENEAL√ìGICO --- */
        .tree-container {
            width: 100%;
            overflow-x: auto;
            padding: 1em;
        }

        .tree {
            display: inline-flex; /* Clave para que el contenedor se ajuste al contenido y permita scroll */
            flex-direction: column;
            align-items: center;
            min-width: 100%;
        }

        .tree ul {
            position: relative;
            padding-top: 20px;
            display: flex;
            justify-content: center;
        }

        .member .profile-pic {
            width: 60px; /* Tama√±o de la imagen */
            height: 60px;
            border-radius: 50%; /* Hacer la imagen redonda */
            object-fit: cover; /* Asegurar que la imagen cubra el √°rea sin distorsionarse */
            border: 2px solid #ddd; /* Peque√±o borde */
            margin-bottom: 5px; /* Margen debajo de la imagen y el nombre */
            box-shadow: 0 2px 4px rgba(0,0,0,0.1); /* Sombra suave */
            margin: 0 auto;
        }

        .tree li {
            list-style-type: none;
            position: relative;
            padding: 20px 5px 0 5px;
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        /* --- Conectores --- */
        /* L√≠nea vertical hacia abajo desde el nodo */
        .tree li::before, .tree li::after {
            content: '';
            position: absolute;
            top: 0;
            right: 50%;
            border-top: 2px solid #ccc;
            width: 50%;
            height: 20px;
        }

        /* L√≠nea horizontal */
        .tree li::after {
            right: auto;
            left: 50%;
            border-left: 2px solid #ccc;
        }

        /* Ocultar conectores innecesarios para nodos √∫nicos */
        .tree li:only-child::after, .tree li:only-child::before {
            display: none;
        }

        .tree li:only-child {
            padding-top: 0;
        }

        /* Eliminar borde izquierdo del primer hijo y derecho del √∫ltimo */
        .tree li:first-child::before, .tree li:last-child::after {
            border: 0 none;
        }

        /* Conector derecho para el √∫ltimo hijo */
        .tree li:last-child::before {
            border-right: 2px solid #ccc;
            border-radius: 0 5px 0 0;
        }

        /* Conector izquierdo para el primer hijo */
        .tree li:first-child::after {
            border-radius: 5px 0 0 0;
        }

        /* Conector vertical para la lista de hijos */
        .tree ul ul::before {
            content: '';
            position: absolute;
            top: 0;
            left: 50%;
            border-left: 2px solid #ccc;
            width: 0;
            height: 20px;
        }
        
        /* Ocultar l√≠neas que suben desde los nodos ra√≠z */
        .tree > ul > li::before, .tree > ul > li::after {
             display: none;
        }

        .node-content {
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative; /* Para la l√≠nea del c√≥nyuge */
        }

        .member {
            border: 2px solid #ccc;
            padding: 10px 15px;
            text-decoration: none;
            display: inline-block;
            border-radius: 8px;
            transition: all 0.3s;
            cursor: pointer;
            background-color: #fff;
            min-width: 140px;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            display: flex; /* Usar flexbox para alinear contenido */
            flex-direction: column; /* Apilar elementos verticalmente */
            align-items: center; /* Centrar horizontalmente */
        }

        .tree li .member:hover, .tree li .member.selected {
            background-color: #e0f2fe;
            transform: translateY(-2px);
            box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        .member .name {
            font-weight: 600;
            margin-top: 5px; /* Espacio entre la imagen y el nombre */
        }

        .member .relationship {
            font-size: 0.8em;
            color: #666;
        }

        .member .age {
            font-size: 0.7em; /* Un poco m√°s peque√±a que la relaci√≥n */
            color: #999;
            margin-top: 0.2em; /* Peque√±o margen superior */
        }
        
        /* L√≠nea que une a los c√≥nyuges */
        .spouse-line {
            height: 2px;
            width: 20px; /* Ancho de la l√≠nea */
            background-color: #ccc;
        }

        /* Estilos para el panel de detalles para que sea sticky y responsivo */
        @media (min-width: 1024px) { /* lg breakpoint */
            .sticky-lg {
                position: sticky;
                top: 2rem; /* Distancia desde la parte superior */
            }
        }

        /* --- ESTILOS PARA RESALTADO DE ANCESTROS (Mantenidos) --- */
        .member.highlighted {
            border-color: #10b981  !important;
            box-shadow: 0 4px 6px -1px rgba(16, 185, 129, 0.2), 0 2px 4px -2px rgba(16, 185, 129, 0.1) ;
        }


        /* Para la l√≠nea vertical que une la lista de hijos (de la pareja resaltada) */
        .tree li.highlighted-path ul::before {
            border-left-color: #10b981 ;
        }

        /* Asegurarse de que el c√≥nyuge de un ancestro tambi√©n tenga la l√≠nea resaltada */
        .node-content.highlighted-path .spouse-line {
            background-color: #10b981 !important;
        }
        
        /* Para asegurar que el c√≥nyuge del ancestro directo tambi√©n se vea resaltado visualmente */
        .member.ancestor-spouse-highlight {
            background-color: #d1fae5; /* Mismo verde para el c√≥nyuge del ancestro */
            border-color: #10b981  !important;
            box-shadow: 0 4px 6px -1px rgba(16, 185, 129, 0.2), 0 2px 4px -2px rgba(16, 185, 129, 0.1);
        }

        .member.male {
            border-color: #4a90e2;
            background: linear-gradient(145deg, #ffffff 0%, #f0f8ff 100%);
        }

        .member.female {
            border-color: #e24a90;
            background: linear-gradient(145deg, #ffffff 0%, #fff0f8 100%);
        }

        .deceased {
            opacity: 0.8;
            position: relative;
        }

        .deceased::after {
            content: '‚úù';
            position: absolute;
            top: -5px;
            left: -5px;
            background: #666;
            color: white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
        }

        /* Nuevo estilo para el gorrito de cumplea√±os */
        .member.birthday::before {
            content: 'üéÇ'; /* Emoji de pastel o gorrito */
            position: absolute;
            top: -10px; /* Ajusta la posici√≥n vertical */
            right: -10px; /* Ajusta la posici√≥n horizontal */
            font-size: 1.5em; /* Tama√±o del gorrito */
            z-index: 10; /* Asegura que est√© por encima del cuadro del miembro */
            transform: rotate(15deg); /* Peque√±a rotaci√≥n para efecto divertido */
        }

         /* Nuevos estilos para los iconos condicionales */
        .member .icon-status {
            position: absolute;
            font-size: 0.9em;
            background-color: #fff;
            border-radius: 50%;
            padding: 2px;
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
            z-index: 5; /* Por encima del miembro, pero debajo del gorrito */
        }


        .member .icon-child {
            top: -5px; /* Posici√≥n superior izquierda */
            /*left: -5px;*/
            font-size: 1.1em; /* Un poco m√°s grande para el icono de ni√±o */
        }

       /* --- ESTILOS PARA EL COLAPSO HORIZONTAL DEL PANEL DE DETALLES --- */

        /* Nuevo selector para el contenedor <aside> */
        .details-panel-container {
            /* Prepara la transici√≥n para el ancho */
            transition: width 0.3s ease-in-out, min-width 0.3s ease-in-out;
            width: 100%; /* Ancho completo en m√≥viles */
            min-width: 100%;
        }

        /* Reglas para pantallas grandes (lg: - 1024px y m√°s) */
        @media (min-width: 1024px) {
     

            .details-panel-container.collapsed-horizontal {
                /* Estado Colapsado: solo ancho suficiente para el encabezado */
                overflow: hidden; /* Oculta el contenido que sobresale */
            }

            /* Ocultar el contenido interno cuando est√° colapsado */
            .details-panel-container.collapsed-horizontal #collapsible-content {
                visibility: hidden;
                opacity: 0;
                transition: opacity 0.1s; /* Transici√≥n r√°pida para ocultar el contenido */
            }
        }

        /* Rotaci√≥n del icono para indicar el estado */
        #collapse-icon {
            /* Estado Inicial (Expandido): Rotaci√≥n para apuntar a la IZQUIERDA */
            transform: rotate(-90deg); 
            transition: transform 0.3s ease-in-out;
        }

        .details-panel-container.collapsed-horizontal #collapse-icon {
            /* Estado Colapsado: Rotaci√≥n para apuntar a la DERECHA */
            transform: rotate(90deg); 
        }

        /* --- ESTILOS BASE Y TRANSICI√ìN --- */

        /* Contenedor principal para la gesti√≥n de ancho (flexbox en pantallas grandes) */
        @media (min-width: 1024px) {
            #main-layout {
                display: flex;
                flex-direction: row;
            }

            /* El contenido principal debe tener transici√≥n de ancho */
            #main-content {
                transition: width 0.3s ease-in-out;
                height: 100%;
            }

            /* El panel lateral debe tener transici√≥n de ancho */
            #aside-container {
                width: 25%; /* Ancho inicial (1/4) */
                min-width: 300px; /* Asegura un ancho legible */
                overflow: hidden;
                          height: 100%;
                transition: width 0.3s ease-in-out, min-width 0.3s ease-in-out;
            }

            /* --- ESTADO COLAPSADO (Se aplica a #main-layout) --- */

            #main-layout.aside-collapsed #main-content {
                /* El Main Content se expande para ocupar todo el espacio restante */
                width: calc(100% - 50px);
            }

            #main-layout.aside-collapsed #aside-container {
                /* El Aside se colapsa a un ancho fijo (por ejemplo, 50px para solo mostrar el t√≠tulo/icono) */
                width: 50px; 
                min-width: 50px;
                height: 700px;
      
            }

            /* Ocultar el contenido interno (detalles, botones) cuando est√° colapsado */
            #main-layout.aside-collapsed #collapsible-content {
                visibility: hidden;
                opacity: 0;
                transition: opacity 0.1s;
            }
        }

        /* --- ROTACI√ìN DEL ICONO --- */

        #collapse-icon {
            /* Estado Inicial (Expandido): Apunta a la IZQUIERDA */
            transform: rotate(90deg); 
            transition: transform 0.3s ease-in-out;
        }

        #main-layout.aside-collapsed #collapse-icon {
            /* Estado Colapsado: Apunta a la DERECHA (despu√©s de colapsarse, el icono debe rotar) */
            transform: rotate(-90deg); 
        }

    </style>
</head>
<body class="bg-gray-100 text-gray-800">

    <div class="mx-auto p-4 md:p-8">
        <header class="mb-8 relative"> 
            <div class="flex justify-between items-start"> 
                <div class="flex-grow"></div> 
                
                <div class="text-center"> 
                    <h1 class="text-3xl md:text-5xl font-bold text-gray-800">√Årbol Geneal√≥gico Familiar</h1>
                    <p class="text-gray-600 mt-2">Un vistazo a nuestras ra√≠ces y nuestra historia.</p>
                </div>

           
                <div class="flex-grow text-right">
                      <a href="dashboard.html" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg whitespace-nowrap transition duration-300 ease-in-out transform hover:-translate-y-1 mr-2">
                        <i class="fas fa-chart-bar mr-2"></i> Ver Dashboard
                    </a>
                    <a href="buscar.html" class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-lg whitespace-nowrap transition duration-300 ease-in-out transform hover:-translate-y-1">Buscar Personas</a>
                  
                </div>
            </div>
        </header>
        <div id="main-layout" class="flex flex-col lg:flex-row gap-8">
            <main id="main-content" class="w-full lg:w-3/4 bg-white p-6 rounded-lg shadow-lg">
                <div id="family-tree-container" class="tree-container">
                    <div class="tree">
                        </div>
                </div>
            </main>
           <aside id="aside-container" class="w-full details-panel-container">
                <div id="details-panel" class="bg-white p-6 rounded-lg shadow-lg sticky-lg">
                    
                    <h2 id="details-header" class="text-2xl font-bold mb-4 border-b pb-2 text-center cursor-pointer flex justify-between items-center">
                        Detalles de la Persona
                        <span id="collapse-icon" class="text-xl transition-transform duration-300">
                            &#9660; 
                        </span>
                    </h2>
                    
                    <div id="collapsible-content">
                        <div id="details-content" class="text-center">
                            <p class="text-gray-500">Selecciona una persona para ver su informaci√≥n.</p>
                        </div>
                        <div id="edit-buttons" class="mt-6 hidden">
                            <button id="add-descendant-btn" class="w-full bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg mb-2 transition duration-300 ease-in-out transform hover:-translate-y-1">Agregar Descendencia</button>
                            <button id="add-ancestor-btn" class="w-full bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg mb-2 transition duration-300 ease-in-out transform hover:-translate-y-1">Agregar Ascendencia</button>
                            <button id="manage-relationships-btn" class="w-full bg-orange-500 hover:bg-orange-600 text-white font-bold py-2 px-4 rounded-lg mb-2 transition duration-300 ease-in-out transform hover:-translate-y-1">Gestionar Relaciones</button> 
                            <a id="edit-person-link" href="#" class="w-full text-center bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-2 px-4 mb-2 rounded-lg block transition duration-300 ease-in-out transform hover:-translate-y-1">Editar Persona</a>
                            <button id="export-tree-png" class="w-full bg-purple-500 hover:bg-purple-600 text-white font-bold py-2 px-4 rounded-lg mb-2 transition duration-300 ease-in-out transform hover:-translate-y-1">Exportar √Årbol (PNG)</button>
                            <button id="export-tree-pdf" class="w-full bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg transition duration-300 ease-in-out transform hover:-translate-y-1">Exportar √Årbol (PDF)</button>
                        </div>
                    </div>
                </div>
            </aside>
        </div>
    </div>
    
    <div id="person-modal" class="fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full hidden z-50 flex items-center justify-center p-4">
      <div class="relative top-0 mx-auto p-5 border w-full max-w-lg shadow-lg rounded-md bg-white animate-fade-in-up">
        <div class="mt-3">
          <h3 class="text-lg leading-6 font-medium text-gray-900 mb-4" id="modal-title">Agregar Persona</h3>
          <form id="person-form">
            <input type="hidden" id="person-id"> 
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
              <input class="w-full bg-gray-100 text-gray-900 mt-2 p-3 rounded-lg focus:outline-none focus:shadow-outline focus:border-blue-500 border border-gray-200 transition duration-200" type="text" id="name" placeholder="Nombre Completo*" required>
              <input class="w-full bg-gray-100 text-gray-900 mt-2 p-3 rounded-lg focus:outline-none focus:shadow-outline focus:border-blue-500 border border-gray-200 transition duration-200" type="text" id="relationship" placeholder="Relaci√≥n (Ej: T√≠o, Prima)">
              <input class="w-full bg-gray-100 text-gray-900 mt-2 p-3 rounded-lg focus:outline-none focus:shadow-outline focus:border-blue-500 border border-gray-200 transition duration-200" type="text" id="rut" placeholder="RUT">
              <select id="gender" class="w-full bg-gray-100 text-gray-900 mt-2 p-3 rounded-lg focus:outline-none focus:shadow-outline focus:border-blue-500 border border-gray-200 transition duration-200">
                <option value="Masculino">Masculino</option>
                <option value="Femenino">Femenino</option>
                <option value="Otro">Otro</option>
              </select>
              <input class="w-full bg-gray-100 text-gray-900 mt-2 p-3 rounded-lg focus:outline-none focus:shadow-outline focus:border-blue-500 border border-gray-200 transition duration-200" type="text" onfocus="(this.type='date')" onblur="(this.type='text')" id="dob" placeholder="Fecha de Nacimiento">
              <input class="w-full bg-gray-100 text-gray-900 mt-2 p-3 rounded-lg focus:outline-none focus:shadow-outline focus:border-blue-500 border border-gray-200 transition duration-200" type="text" onfocus="(this.type='date')" onblur="(this.type='text')" id="dom" placeholder="Fecha de Matrimonio">
              <input class="w-full bg-gray-100 text-gray-900 mt-2 p-3 rounded-lg focus:outline-none focus:shadow-outline focus:border-blue-500 border border-gray-200 transition duration-200" type="text" onfocus="(this.type='date')" onblur="(this.type='text')" id="dod" placeholder="Fecha de Fallecimiento">
              <input class="w-full bg-gray-100 text-gray-900 mt-2 p-3 rounded-lg focus:outline-none focus:shadow-outline focus:border-blue-500 border border-gray-200 transition duration-200" type="text" id="photo" placeholder="URL de la Foto">
            </div>
            
            <div class="mt-6 flex justify-end gap-4">
              <button type="button" id="cancel-btn" class="px-4 py-2 bg-gray-200 text-gray-800 rounded-md hover:bg-gray-300 transition duration-300 ease-in-out">Cancelar</button>
              <button type="submit" class="px-4 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 transition duration-300 ease-in-out">Guardar</button>
            </div>
          </form>
        </div>
      </div>
    </div>

    <div id="relationships-modal" class="fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full hidden z-50 flex items-center justify-center p-4">
        <div class="relative top-0 mx-auto p-5 border w-full max-w-2xl shadow-lg rounded-md bg-white animate-fade-in-up">
            <div class="mt-3">
                <h3 class="text-lg leading-6 font-medium text-gray-900 mb-4">Gestionar Relaciones de <span id="relationship-person-name" class="font-bold"></span></h3>
                
                <div class="space-y-4">
                    <div>
                        <h4 class="text-md font-semibold mb-2 text-gray-700">C√≥nyuge</h4>
                        <div id="current-spouse-display" class="flex items-center justify-between p-3 bg-gray-100 rounded-md border border-gray-200">
                            <p class="text-gray-500">No hay c√≥nyuge asignado.</p>
                        </div>
                        <div class="mt-2 flex gap-2">
                            <button id="add-new-spouse-btn" class="px-4 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 text-sm transition duration-300 ease-in-out">Agregar Nuevo</button>
                            <button id="link-existing-spouse-btn" class="px-4 py-2 bg-purple-500 text-white rounded-md hover:bg-purple-600 text-sm transition duration-300 ease-in-out">Vincular Existente</button>
                        </div>
                    </div>

                    <div>
                        <h4 class="text-md font-semibold mb-2 text-gray-700">Padres</h4>
                        <div id="current-parents-list" class="space-y-2">
                            <p class="text-gray-500">No hay padres asignados.</p>
                        </div>
                        <div class="mt-2 flex gap-2">
                            <button id="add-new-parent-btn" class="px-4 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 text-sm transition duration-300 ease-in-out">Agregar Nuevo</button>
                            <button id="link-existing-parent-btn" class="px-4 py-2 bg-purple-500 text-white rounded-md hover:bg-purple-600 text-sm transition duration-300 ease-in-out">Vincular Existente</button>
                        </div>
                    </div>

                    <div>
                        <h4 class="text-md font-semibold mb-2 text-gray-700">Hijos/as</h4>
                        <div id="current-children-list" class="space-y-2">
                            <p class="text-gray-500">No hay hijos/as asignados.</p>
                        </div>
                        <div class="mt-2 flex gap-2">
                            <button id="add-new-child-btn" class="px-4 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 text-sm transition duration-300 ease-in-out">Agregar Nuevo</button>
                            <button id="link-existing-child-btn" class="px-4 py-2 bg-purple-500 text-white rounded-md hover:bg-purple-600 text-sm transition duration-300 ease-in-out">Vincular Existente</button>
                        </div>
                    </div>
                </div>

                <div class="mt-6 flex justify-end">
                    <button type="button" id="close-relationships-modal-btn" class="px-4 py-2 bg-gray-200 text-gray-800 rounded-md hover:bg-gray-300 transition duration-300 ease-in-out">Cerrar</button>
                </div>
            </div>
        </div>
    </div>

    <div id="select-person-modal" class="fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full hidden z-50 flex items-center justify-center p-4">
        <div class="relative top-0 mx-auto p-5 border w-full max-w-md shadow-lg rounded-md bg-white animate-fade-in-up">
            <div class="mt-3">
                <h3 class="text-lg leading-6 font-medium text-gray-900 mb-4" id="select-modal-title">Seleccionar Persona</h3>
                <input type="text" id="person-search-input" placeholder="Buscar por nombre..." class="w-full bg-gray-100 text-gray-900 p-2 rounded-lg focus:outline-none focus:shadow-outline focus:border-blue-500 border border-gray-200 transition duration-200 mb-4">
                <div id="person-list-container" class="max-h-60 overflow-y-auto border border-gray-200 rounded-md">
                    </div>
                <div class="mt-4 flex justify-end">
                    <button type="button" id="cancel-select-person-btn" class="px-4 py-2 bg-gray-200 text-gray-800 rounded-md hover:bg-gray-300 transition duration-300 ease-in-out">Cancelar</button>
                </div>
            </div>
        </div>
    </div>


    <script type="module">
        let familyData = new Map();
        let selectedPersonId = null;
        let modalMode = ''; 
        let relatedPersonId = null; 
        let relatedPersonSpouseId = null; 

        let selectPersonMode = ''; 
        let personToLinkToId = null; 


        const API_URL = 'api.php';

       
        async function loadFamilyData() {
            try {
                const response = await fetch(API_URL, {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = await response.json();
                
                familyData.clear();
                data.forEach(person => {
                    person.id = parseInt(person.id);
                    person.spouseId = person.spouse_id !== null ? parseInt(person.spouse_id) : null;
                    
                    person.childrenIds = Array.isArray(person.children_ids) ? person.children_ids.map(id => parseInt(id)) : [];
                    person.parentIds = Array.isArray(person.parent_ids) ? person.parent_ids.map(id => parseInt(id)) : [];

                    familyData.set(person.id, person);
                });

                console.log('Datos cargados en familyData (con IDs parseados):', familyData);
                
                const urlParams = new URLSearchParams(window.location.search);
                const idFromUrl = urlParams.get('personId');

                // L√≥gica de carga y selecci√≥n de la persona principal para el √°rbol
                if (idFromUrl && familyData.has(parseInt(idFromUrl))) {
                    selectedPersonId = parseInt(idFromUrl); 
                } else if (familyData.size > 0) {
                    if (familyData.has(1)) { 
                        selectedPersonId = 1; // Priorizar ID 1 si existe
                    } else { 
                        selectedPersonId = Array.from(familyData.keys())[0]; // Tomar la primera persona si no hay ID 1
                    }
                } else {
                    selectedPersonId = null; // No hay personas en la base de datos
                }

                renderTree(); // Llama a renderTree despu√©s de decidir la persona principal
                
                if (selectedPersonId) {
                    showPersonDetails(selectedPersonId);
                } else {
                    document.getElementById('details-content').innerHTML = '<p class="text-gray-500">No hay datos en el √°rbol. ¬°A√±ade la primera persona!</p>';
                    document.getElementById('edit-buttons').classList.add('hidden');
                }

            } catch (error) {
                console.error('Error al cargar los datos de la familia:', error);
                document.getElementById('details-content').innerHTML = '<p class="text-red-500">Error al cargar los datos. Intenta de nuevo m√°s tarde.</p>';
            }
        }

        async function sendDataToAPI(actionData) {
            try {
                const response = await fetch(API_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(actionData),
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`HTTP error! status: ${response.status}, message: ${errorText}`);
                }

                const result = await response.json();
                if (result.success) {
                    console.log('Operaci√≥n exitosa:', result.message);
                    await loadFamilyData(); 
                    return result; 
                } else {
                    console.error('Error en la operaci√≥n en la base de datos:', result.message);
                    alert('Error al guardar: ' + result.message + (result.error ? `\nDetalles: ${result.error}` : ''));
                    return null;
                }
            } catch (error) {
                console.error('Error de red o servidor al guardar:', error);
                alert('Error de conexi√≥n o servidor al guardar los datos.');
                return null;
            }
        }

        // Funci√≥n auxiliar para obtener todos los ancestros de una persona y su distancia generacional
        // Retorna un Map<personId, distance> donde distance es 0 para la persona original, 1 para padres, etc.
        function getAncestorsWithDistance(personId) {
            const ancestors = new Map(); // Map<id, distance>
            let queue = [{id: personId, dist: 0}];
            let head = 0;

            while(head < queue.length) {
                const { id: currentId, dist: currentDist } = queue[head++];
                if (ancestors.has(currentId) && ancestors.get(currentId) <= currentDist) {
                    continue; // Ya visitado con una distancia menor o igual
                }
                ancestors.set(currentId, currentDist);

                const person = familyData.get(currentId);
                if (person && person.parentIds) {
                    person.parentIds.forEach(parentId => {
                        // Solo a√±adir si el padre existe en los datos cargados y no se ha visitado o se encontr√≥ a mayor distancia
                        if (familyData.has(parentId) && (!ancestors.has(parentId) || ancestors.get(parentId) > currentDist + 1)) {
                            queue.push({id: parentId, dist: currentDist + 1});
                        }
                    });
                }
            }
            return ancestors;
        }

        // Funci√≥n auxiliar para obtener todos los descendientes de una persona y su distancia generacional
        // Retorna un Map<personId, distance> donde distance es 0 para la persona original, 1 para hijos, etc.
        function getDescendantsWithDistance(personId) {
            const descendants = new Map(); // Map<id, distance>
            let queue = [{id: personId, dist: 0}];
            let head = 0;

            while(head < queue.length) {
                const { id: currentId, dist: currentDist } = queue[head++];
                if (descendants.has(currentId) && descendants.get(currentId) <= currentDist) {
                    continue; 
                }
                descendants.set(currentId, currentDist);

                const person = familyData.get(currentId);
                // Necesitamos encontrar personas que tengan a 'currentId' como uno de sus padres
                const children = Array.from(familyData.values()).filter(p => p.parentIds && p.parentIds.includes(currentId));

                children.forEach(child => {
                    // Solo a√±adir si el hijo existe y no se ha visitado o se encontr√≥ a mayor distancia
                    if (familyData.has(child.id) && (!descendants.has(child.id) || descendants.get(child.id) > currentDist + 1)) {
                        queue.push({id: child.id, dist: currentDist + 1});
                    }
                });
            }
            return descendants;
        }


        // --- INICIO DE CAMBIOS EN renderTree ---
        function renderTree() {
            const container = document.querySelector('.tree');
            if (!container) return;

            container.innerHTML = ''; 

            if (!selectedPersonId || !familyData.has(selectedPersonId)) {
                container.innerHTML = '<p class="text-gray-500 text-center">Selecciona una persona o agrega la primera para construir el √°rbol.</p>';
                return;
            }

            const centralPerson = familyData.get(selectedPersonId);
            let finalRootsToRender = new Set(); // IDs de las personas que ser√°n las ra√≠ces del √°rbol visualizado

            // Si la persona central tiene padres, subimos por sus linajes para encontrar las ra√≠ces m√°s altas
            if (centralPerson.parentIds && centralPerson.parentIds.length > 0) {
                const parentsToProcess = new Set(centralPerson.parentIds.filter(pId => familyData.has(pId)));
                if (centralPerson.spouseId && familyData.has(centralPerson.spouseId) && familyData.get(centralPerson.spouseId).spouseId === centralPerson.id) {
                    // Si la persona central tiene un c√≥nyuge rec√≠proco, tambi√©n consideramos los padres del c√≥nyuge
                    const spouse = familyData.get(centralPerson.spouseId);
                    if (spouse.parentIds) {
                        spouse.parentIds.forEach(pId => {
                            if (familyData.has(pId)) parentsToProcess.add(pId);
                        });
                    }
                }

                // Para cada padre (o c√≥nyuge de padre) que influye en la rama central,
                // encontramos su ancestro m√°s alto que est√© en familyData.
                parentsToProcess.forEach(pId => {
                    let currentAncestor = familyData.get(pId);
                    if (!currentAncestor) return;

                    let hasHigherParentInFamilyData = false;
                    while (currentAncestor) {
                        const directParentsInFamilyData = currentAncestor.parentIds
                            ? currentAncestor.parentIds.filter(paId => familyData.has(paId))
                            : [];

                        if (directParentsInFamilyData.length > 0) {
                            hasHigherParentInFamilyData = true;
                            // Moverse al primer padre encontrado para seguir subiendo
                            currentAncestor = familyData.get(directParentsInFamilyData[0]);
                        } else {
                            // No m√°s padres cargados, esta es la ra√≠z de esta rama ascendente
                            break;
                        }
                    }
                    // Si se encontr√≥ una ra√≠z (no es null) Y esa ra√≠z no tiene padres EN FAMILYDATA
                    if (currentAncestor && !(currentAncestor.parentIds && currentAncestor.parentIds.some(pid => familyData.has(pid)))) {
                         finalRootsToRender.add(currentAncestor.id);
                    } else if (currentAncestor) { // Si currentAncestor no es null pero a√∫n tiene padres en familyData
                        finalRootsToRender.add(currentAncestor.id); // Lo agrega de todas formas como una potencial ra√≠z de su sub-rama
                    }
                });

                // Si no encontramos ninguna ra√≠z a trav√©s de los padres (ej. solo tiene un padre que ya es la ra√≠z),
                // o si los padres mismos son las ra√≠ces m√°s altas, las a√±adimos.
                if (finalRootsToRender.size === 0) {
                    parentsToProcess.forEach(id => finalRootsToRender.add(id));
                }

            } else {
                // Si la persona central no tiene padres, ella misma es la ra√≠z del √°rbol a mostrar.
                finalRootsToRender.add(centralPerson.id);
            }
            
            // Convertir el Set de IDs a un array de objetos Persona y ordenar
            let displayRoots = Array.from(finalRootsToRender)
                                .map(id => familyData.get(id))
                                .filter(p => p !== undefined)
                                .sort((a,b) => a.id - b.id); 

            // Si despu√©s de toda la l√≥gica no se tiene una ra√≠z, usar la persona central como fallback
            if (displayRoots.length === 0) {
                displayRoots.push(centralPerson);
            }

            let treeHtmlContent = '';
            const renderedIdsForWholeTree = new Set(); 

            displayRoots.forEach(root => {
                treeHtmlContent += generatePersonHtml(root, renderedIdsForWholeTree);
            });

            container.innerHTML = '<ul>' + treeHtmlContent + '</ul>';
            addClickListeners(); 
            
            setTimeout(() => {
                const selectedMemberElement = document.querySelector(`.member[data-id="${selectedPersonId}"]`);
                if (selectedMemberElement) {
                    const treeContainer = document.getElementById('family-tree-container');
                    const offsetLeft = selectedMemberElement.offsetLeft - (treeContainer.offsetWidth / 2) + (selectedMemberElement.offsetWidth / 2);
                    treeContainer.scrollLeft = offsetLeft;

                    const offsetTop = selectedMemberElement.offsetTop - (treeContainer.offsetHeight / 3); 
                    treeContainer.scrollTop = offsetTop;
                }
            }, 100); 
        }
        // --- FIN DE CAMBIOS EN renderTree ---


        // Funci√≥n auxiliar para obtener el ordinal para los grados de primos, t√≠os, etc.
        function getOrdinal(n) {
            const s = ["", "Segundo", "Tercer", "Cuarto", "Quinto", "Sexto", "S√©ptimo", "Octavo", "Noveno", "D√©cimo"];
            if (n >= 1 && n <= s.length) {
                return s[n - 1];
            }
            return `${n}¬∫`; 
        }


        // --- FUNCI√ìN PRINCIPAL PARA CALCULAR LA RELACI√ìN DIN√ÅMICA ---
        function generatePersonHtml(person, renderedIds = new Set()) {
            if (!person || renderedIds.has(person.id)) return ''; 

            renderedIds.add(person.id); 

            const currentIsMale = (person.gender === 'Masculino');
            const currentIsFemale = (person.gender === 'Femenino');

            let ageInTree = '';
                        if (person.dob && person.dob !== '0000-00-00') {
                try {
                    const birthDate = new Date(person.dob);
                    let endDate = new Date(); // Por defecto, hoy

                    const hasDeathDate = person.dod && person.dod !== '0000-00-00';
                    if (hasDeathDate) {
                        endDate = new Date(person.dod);
                    }

                    if(!isNaN(birthDate.getTime()) && !isNaN(endDate.getTime())){
                        let ageDiff = endDate.getFullYear() - birthDate.getFullYear();
                        const m = endDate.getMonth() - birthDate.getMonth();
                        if (m < 0 || (m === 0 && endDate.getDate() < birthDate.getDate())) {
                            ageDiff--;
                        }
                        if (ageDiff >= 0) { 
                            ageInTree = `<div class="age">${ageDiff} a√±os${hasDeathDate ? `${currentIsMale ? ' (fallecido)' : ' (fallecida)'}` : ''}</div>`;
                        }
                    }
                } catch(e) { console.error("Error calculating age for tree node", e); }
            }

            // Determinar si la persona ha fallecido para a√±adir la clase 'deceased'
            const isDeceased = person.dod && person.dod !== '0000-00-00';
            

            let nodeContent = '<div class="node-content">';

                        const getShortName = (fullName) => {
                if (!fullName) return '';

                const parts = fullName.trim().split(/\s+/); // separa por espacios

                if (parts.length === 1) return parts[0]; // solo un nombre
                if (parts.length === 2) return `${parts[0]} ${parts[1]}`; // nombre + apellido

                const firstName = parts[0];
                const lastName = parts[parts.length - 2]; // pen√∫ltima palabra = primer apellido

                return `${firstName} ${lastName}`;
            };

            const getProfilePicHtml = (photoUrl, name) => {
                const defaultPhoto = 'https://placehold.co/60x60/E2E8F0/333333?text=Foto';
                if (photoUrl && photoUrl.trim() !== '') {
                    return `<img src="${photoUrl}" alt="Foto de ${name}" class="profile-pic" onerror="this.onerror=null;this.src='${defaultPhoto}';">`;
                }
                return `<img src="${defaultPhoto}" alt="Sin foto" class="profile-pic">`;
            };

   

            const calculateDynamicRelationship = (currentPersonId, referencePersonId) => {
                const currentPerson = familyData.get(currentPersonId);
                const referencePerson = familyData.get(referencePersonId);

                if (!currentPerson || !referencePerson) {
                    return 'Desconocido';
                }
                
                const currentIsMale = (currentPerson.gender === 'Masculino');
                const currentIsFemale = (currentPerson.gender === 'Femenino');


                // 0. La persona misma
                if (currentPersonId === referencePersonId) {
                    return 'T√∫';
                }

                // Caching de ancestros y descendientes para evitar recalcular
                const refAncestorsWithDist = getAncestorsWithDistance(referencePersonId);
                const refDescendantsWithDist = getDescendantsWithDistance(referencePersonId);
                const currentAncestorsWithDist = getAncestorsWithDistance(currentPersonId);
                const currentDescendantsWithDist = getDescendantsWithDistance(currentPersonId);


                // 1. C√≥nyuge
                if (currentPerson.spouseId === referencePersonId && referencePerson.spouseId === currentPersonId) {
                    return 'C√≥nyuge';
                }

                // 2. Relaciones Directas Ascendentes (Padres, Abuelos, Bisabuelos, etc.)
                const distToRefAnc = refAncestorsWithDist.get(currentPersonId);
                if (distToRefAnc !== undefined) {
                    if (distToRefAnc === 1) return currentIsMale ? 'Padre' : (currentIsFemale ? 'Madre' : 'Padre/Madre');
                    if (distToRefAnc === 2) return currentIsMale ? 'Abuelo' : (currentIsFemale ? 'Abuela' : 'Abuelo/a');
                    if (distToRefAnc === 3) return currentIsMale ? 'Bisabuelo' : (currentIsFemale ? 'Bisabuela' : 'Bisabuelo/a');
                    if (distToRefAnc === 4) return currentIsMale ? 'Tatarabuelo' : (currentIsFemale ? 'Tatarabuela' : 'Tatarabuelo/a');
                    if (distToRefAnc === 5) return currentIsMale ? 'Trastatarabuelo' : (currentIsFemale ? 'Trastatarabuela' : 'Trastatarabuelo/a');
                }

                // 3. Relaciones Directas Descendentes (Hijos, Nietos, Bisnietos, etc.)
                const distToRefDesc = refDescendantsWithDist.get(currentPersonId);
                if (distToRefDesc !== undefined) {
                    if (distToRefDesc === 1) return currentIsMale ? 'Hijo' : (currentIsFemale ? 'Hija' : 'Hijo/a');
                    if (distToRefDesc === 2) return currentIsMale ? 'Nieto' : (currentIsFemale ? 'Nieta' : 'Nieto/a');
                    if (distToRefDesc === 3) return currentIsMale ? 'Bisnieto' : (currentIsFemale ? 'Bisnieta' : 'Bisnieto/a');
                    if (distToRefDesc === 4) return currentIsMale ? 'Tataranieto' : (currentIsFemale ? 'Tataranieta' : 'Tataranieto/a');
                    if (distToRefDesc === 5) return currentIsMale ? 'Trastataranieto' : (currentIsFemale ? 'Trastataranieta' : 'Trastataranieto/a');
                }

                // --- NUEVAS RELACIONES POL√çTICAS Y COLATERALES ---

                // Padrastro/Madrastra: C√≥nyuge de un padre biol√≥gico de referencePerson, que no es el padre biol√≥gico
                // referencePerson.parentIds son los padres biol√≥gicos de referencePerson.
                // currentPerson es el c√≥nyuge de uno de ellos y no es uno de ellos.
                if (referencePerson.parentIds && referencePerson.parentIds.length > 0) {
                    for (const parentId of referencePerson.parentIds) {
                        const biologicalParent = familyData.get(parentId);
                        if (biologicalParent && biologicalParent.spouseId === currentPersonId && currentPerson.spouseId === biologicalParent.id) {
                            // currentPerson es el c√≥nyuge del padre/madre de referencePerson
                            // Y currentPerson NO es el padre/madre biol√≥gico de referencePerson
                            if (!referencePerson.parentIds.includes(currentPersonId)) {
                                return currentIsMale ? 'Padrastro' : (currentIsFemale ? 'Madrastra' : 'Padrastro/Madrastra');
                            }
                        }
                    }
                }

                // Hijastros (Hijo/a de mi c√≥nyuge pero no m√≠o)
                // currentPerson es hijo/a de referencePerson.spouseId, pero referencePerson no es padre de currentPerson
                if (referencePerson.spouseId && familyData.has(referencePerson.spouseId)) {
                    const refSpouse = familyData.get(referencePerson.spouseId);
                    if (refSpouse && Array.isArray(refSpouse.childrenIds) && refSpouse.childrenIds.includes(currentPersonId)) {
                        // currentPerson es hijo de refSpouse
                        // Ahora, verificar que referencePerson NO sea padre de currentPerson
                        if (!Array.isArray(currentPerson.parentIds) || !currentPerson.parentIds.includes(referencePersonId)) {
                            return currentIsMale ? 'Hijastro' : (currentIsFemale ? 'Hijastra' : 'Hijastro/a');
                        }
                    }
                }

                 // 4. Relaciones Colaterales - Hermanos (ya lo tienes, va antes de otras colaterales)
                if (currentPerson.parentIds && referencePerson.parentIds) {
                    const commonParents = currentPerson.parentIds.filter(pId => referencePerson.parentIds.includes(pId));
                    if (commonParents.length > 0) {
                        // Si ya se ha manejado la relaci√≥n directa (Padre, Hijo),
                        // esta es la comprobaci√≥n para hermanos.
                        if (currentPersonId !== referencePersonId) { // Asegurarse de que no sea la misma persona
                            return currentIsMale ? 'Hermano' : (currentIsFemale ? 'Hermana' : 'Hermano/a');
                        }
                    }
                }
                
                // 5. Relaciones Pol√≠ticas
                // Estas se eval√∫an ANTES que las relaciones colaterales complejas porque son muy espec√≠ficas.

                // Cu√±ados: (C√≥nyuge de un hermano/a) O (Hermano/a de un c√≥nyuge)
                // Caso 1: currentPerson es c√≥nyuge de un hermano/a de referencePerson
                if (referencePerson.parentIds && referencePerson.parentIds.length > 0) {
                    const refParents = referencePerson.parentIds.map(id => familyData.get(id)).filter(p => p);
                    for (const refParent of refParents) {
                        if (refParent.childrenIds) {
                            const siblingsOfRefPerson = refParent.childrenIds.filter(sId => sId !== referencePersonId && familyData.has(sId));
                            for (const siblingId of siblingsOfRefPerson) {
                                const sibling = familyData.get(siblingId);
                                if (sibling && sibling.spouseId === currentPersonId && currentPerson.spouseId === siblingId) {
                                    return currentIsMale ? 'Cu√±ado' : (currentIsFemale ? 'Cu√±ada' : 'Cu√±ado/a');
                                }
                            }
                        }
                    }
                }
                // Caso 2: currentPerson es hermano/a del c√≥nyuge de referencePerson
                if (referencePerson.spouseId && familyData.has(referencePerson.spouseId)) {
                    const refSpouse = familyData.get(referencePerson.spouseId);
                    if (refSpouse && currentPerson.parentIds && refSpouse.parentIds) {
                        const commonParentsWithSpouse = currentPerson.parentIds.filter(pId => refSpouse.parentIds.includes(pId));
                        if (commonParentsWithSpouse.length > 0 && currentPersonId !== refSpouse.id) {
                            return currentIsMale ? 'Cu√±ado' : (currentIsFemale ? 'Cu√±ada' : 'Cu√±ado/a');
                        }
                    }
                }
                
                // Suegros: padre del c√≥nyuge de referencePerson
                if (referencePerson.spouseId && familyData.has(referencePerson.spouseId)) {
                    const refSpouse = familyData.get(referencePerson.spouseId);
                    if (refSpouse && refSpouse.parentIds && refSpouse.parentIds.includes(currentPersonId)) {
                        return currentIsMale ? 'Suegro' : (currentIsFemale ? 'Suegra' : 'Suegro/a');
                    }
                }
                // Abuelos Pol√≠ticos: abuelo del c√≥nyuge de referencePerson
                if (referencePerson.spouseId && familyData.has(referencePerson.spouseId)) {
                    const refSpouse = familyData.get(referencePerson.spouseId);
                    if (refSpouse) {
                        const refSpouseAncestors = getAncestorsWithDistance(refSpouse.id);
                        if (refSpouseAncestors.has(currentPersonId) && refSpouseAncestors.get(currentPersonId) === 2) {
                            return currentIsMale ? 'Abuelo Pol√≠tico' : (currentIsFemale ? 'Abuela Pol√≠tica' : 'Abuelo/a Pol√≠tico/a');
                        }
                    }
                }
                
                // Yerno/Nuera: c√≥nyuge de hijo/hija de referencePerson
                if (referencePerson.childrenIds) {
                    for (const childId of referencePerson.childrenIds) {
                        const child = familyData.get(childId);
                        if (child && child.spouseId === currentPersonId && currentPerson.spouseId === child.id) {
                            return currentIsMale ? 'Yerno' : (currentIsFemale ? 'Nuera' : 'Yerno/Nuera');
                        }
                    }
                }

                // 6. Relaciones Colaterales con grados (T√≠os, Sobrinos, Primos) - Se basa en el LCA
                let lowestCommonAncestorId = null;
                let minSumDistances = Infinity;

                // Encontrar el LCA entre currentPerson y referencePerson
                // Es importante que LCA no sea ni currentPerson ni referencePerson
                for (let [idA, distA] of currentAncestorsWithDist.entries()) {
                    if (refAncestorsWithDist.has(idA)) {
                        const distB = refAncestorsWithDist.get(idA);
                        // Asegurarse de que el LCA no es la persona de referencia ni la persona actual
                        if (idA !== currentPersonId && idA !== referencePersonId) {
                            if (distA + distB < minSumDistances) {
                                minSumDistances = distA + distB;
                                lowestCommonAncestorId = idA;
                            }
                        }
                    }
                }
                
                if (lowestCommonAncestorId !== null) {
                    const distCurrentToLCA = currentAncestorsWithDist.get(lowestCommonAncestorId) || 0;
                    const distRefToLCA = refAncestorsWithDist.get(lowestCommonAncestorId) || 0;
                    
                    const collateralDegree = Math.min(distCurrentToLCA, distRefToLCA) - 1; // Grado del "hermano" del ancestro com√∫n
                    const generationalDiff = Math.abs(distCurrentToLCA - distRefToLCA); // Diferencia de generaciones desde el LCA

                    // T√≠os / T√≠as (ya manejado arriba, pero aqu√≠ en contexto de LCA)
                    // Si el LCA es un padre de A (distancia 1) y de B (distancia > 1)
                    if (distCurrentToLCA === 1 && distRefToLCA > 1 && distRefToLCA <= 5) { // current es padre del LCA, y LCA es abuelo de ref
                         // Solo si currentPerson es el padre directo de un ancestro de referencePerson
                         const isParentOfRefAnc = refAncestorsWithDist.has(lowestCommonAncestorId) && (currentPerson.childrenIds && currentPerson.childrenIds.includes(lowestCommonAncestorId));
                         if (isParentOfRefAnc) {
                             return currentIsMale ? 'T√≠o' : (currentIsFemale ? 'T√≠a' : 'T√≠o/a');
                         }
                    }
                    // Sobrinos / Sobrinas (ya manejado arriba, pero aqu√≠ en contexto de LCA)
                    if (distRefToLCA === 1 && distCurrentToLCA > 1 && distCurrentToLCA <= 5) { // ref es padre del LCA, y LCA es abuelo de current
                        // Solo si referencePerson es el padre directo de un ancestro de currentPerson
                        const isParentOfCurrentAnc = currentAncestorsWithDist.has(lowestCommonAncestorId) && (referencePerson.childrenIds && referencePerson.childrenIds.includes(lowestCommonAncestorId));
                        if (isParentOfCurrentAnc) {
                            return currentIsMale ? 'Sobrino' : (currentIsFemale ? 'Sobrina' : 'Sobrino/a');
                        }
                    }

                     // Sobrino/a Pol√≠tico/a (pareja de mi sobrina)
                    // currentPerson es el c√≥nyuge de un sobrino/a de referencePerson
                    if (refDescendantsWithDist.has(currentPerson.spouseId) && refDescendantsWithDist.get(currentPerson.spouseId) === 2) {
                        // currentPerson.spouseId es un sobrino de referencePerson
                        return currentIsMale ? 'Sobrino Pol√≠tico' : (currentIsFemale ? 'Sobrina Pol√≠tica' : 'Sobrino/a Pol√≠tico/a');
                    }

                    // Primos (ambos est√°n a la misma distancia generacional del LCA)
                    if (distCurrentToLCA === distRefToLCA && distCurrentToLCA > 1) {
                        const degree = distCurrentToLCA - 1; // Grado del primo (Primo, Primo Segundo, etc.)
                        return currentIsMale ? `Primo ${getOrdinal(degree)}` : (currentIsFemale ? `Prima ${getOrdinal(degree)}` : `Primo/a ${getOrdinal(degree)}`);
                    }

                    // Relaciones con grados de separaci√≥n generacional (T√≠os Abuelos, Sobrinos Nietos)
                    if (generationalDiff > 0) {
                        if (distCurrentToLCA < distRefToLCA) { // currentPerson es m√°s viejo (T√≠o)
                            // T√≠o Abuelo, T√≠o Bisabuelo, etc.
                            return currentIsMale ? `T√≠o ${getOrdinal(generationalDiff)}` : (currentIsFemale ? `T√≠a ${getOrdinal(generationalDiff)}` : `T√≠o/a ${getOrdinal(generationalDiff)}`);
                        } else { // currentPerson es m√°s joven (Sobrino)
                            // Sobrino Nieto, Sobrino Bisnieto, Tatarasobrino, etc.
                            // Tatarasobrino: collateralDegree = 1 (hermanos), generationalDiff = 3 (hijo de bisnieto de hermano)
                            if (collateralDegree === 1 && generationalDiff === 3) {
                                return currentIsMale ? 'Tatarasobrino' : (currentIsFemale ? 'Tatarasobrina' : 'Tatarasobrino/a');
                            }
                            return currentIsMale ? `Sobrino ${getOrdinal(generationalDiff)}` : (currentIsFemale ? `Sobrina ${getOrdinal(generationalDiff)}` : `Sobrino/a ${getOrdinal(generationalDiff)}`);
                        }
                    }
                }

                // 7. Sobrino/a Pol√≠tico/a: C√≥nyuge de un sobrino/a
                // Primero encontrar los sobrinos de referencePerson
                const refChildren = new Set(referencePerson.childrenIds);
                let potentialNephews = new Set();
                refChildren.forEach(childId => {
                    const child = familyData.get(childId);
                    if (child && child.parentIds) {
                        const commonParents = child.parentIds.filter(pId => referencePerson.parentIds && referencePerson.parentIds.includes(pId));
                        if (commonParents.length > 0) { // Si child es hermano de refPerson
                            // No, refChildren ya son hijos directos de referencePerson.
                            // Para sobrinos, necesitamos hijos de hermanos de referencePerson.
                            // Esto se calcula m√°s arriba en la l√≥gica de sobrinos.
                        }
                    }
                });

                // T√≠o Pol√≠tico: Pareja de mi T√≠o/a biol√≥gico/a
                // currentPerson es c√≥nyuge de X, y X es T√≠o/a biol√≥gico/a de referencePerson
                if (currentPerson.spouseId && familyData.has(currentPerson.spouseId)) {
                    const spouseOfCurrent = familyData.get(currentPerson.spouseId);
                    // Si el c√≥nyuge de currentPerson es t√≠o/t√≠a de referencePerson (ya sea directo o de grados superiores)
                    // Usamos la misma l√≥gica que para identificar T√≠os biol√≥gicos
                    let lcaForSpouse = null;
                    let minSumDistancesForSpouseLCA = Infinity;

                    for (let [idA, distA] of getAncestorsWithDistance(spouseOfCurrent.id).entries()) {
                        if (refAncestorsWithDist.has(idA)) {
                            const distB = refAncestorsWithDist.get(idA);
                            if (distA + distB < minSumDistancesForSpouseLCA) {
                                minSumDistancesForSpouseLCA = distA + distB;
                                lcaForSpouse = idA;
                            }
                        }
                    }

                    if (lcaForSpouse !== null) {
                        const distSpouseToLCA = getAncestorsWithDistance(spouseOfCurrent.id).get(lcaForSpouse) || 0;
                        const distRefToLCA = refAncestorsWithDist.get(lcaForSpouse) || 0;
                        
                        // Condici√≥n para T√≠o/a biol√≥gico: (distancia c√≥nyuge a LCA = 1) Y (distancia ref a LCA = 2)
                        // O m√°s general para t√≠os de grados superiores (ej. T√≠o abuelo)
                        if (distSpouseToLCA < distRefToLCA) { // Spouse es m√°s viejo que ref
                            // Y si tienen un ancestro com√∫n
                            // Para ser "T√≠o/a" (biol√≥gico), el c√≥nyuge debe estar en una generaci√≥n superior y colateral a referencePerson
                            // Distancia de spouse a LCA es 1, 2, etc. (Ej. 1 = hermano del padre)
                            // Distancia de ref a LCA es 2, 3, etc. (Ej. 2 = hijo de hermano del padre)
                            if (distSpouseToLCA > 0 && distRefToLCA > 0 && distRefToLCA === distSpouseToLCA + 1) { // Spouse est√° a 1 generaci√≥n por encima de ref colateral
                                return currentIsMale ? 'T√≠o Pol√≠tico' : (currentIsFemale ? 'T√≠a Pol√≠tica' : 'T√≠o/a Pol√≠tico/a');
                            }
                            // Caso especial para t√≠os m√°s lejanos (T√≠o Abuelo pol√≠tico, etc.)
                            if (distSpouseToLCA > 0 && distRefToLCA > distSpouseToLCA) {
                                return currentIsMale ? `T√≠o Pol√≠tico ${getOrdinal(distRefToLCA - distSpouseToLCA)}` : (currentIsFemale ? `T√≠a Pol√≠tica ${getOrdinal(distRefToLCA - distSpouseToLCA)}` : `T√≠o/a Pol√≠tico/a ${getOrdinal(distRefToLCA - distSpouseToLCA)}`);
                            }
                        }
                    }
                }

                 // Cu√±ado (pareja de mi cu√±ada) / Cu√±ada (pareja de mi cu√±ado)
                // Esto se refiere al c√≥nyuge de tu hermano/a pol√≠tico/a.
                // Es decir, currentPerson es el c√≥nyuge de una persona X, donde X es cu√±ado/a de referencePerson.
                // Para simplificar y evitar bucles, asumiremos que si currentPerson es c√≥nyuge de alguien que ya es cu√±ado/a de referencePerson,
                // entonces currentPerson es tambi√©n un cu√±ado/a de referencePerson.
                // Esta relaci√≥n suele subsumirse bajo la categor√≠a general de "Cu√±ado/a" si ya detectas al cu√±ado principal.
                // Sin embargo, si quieres una etiqueta EXCLUSIVA para "pareja de mi cu√±ada":
                if (currentPerson.spouseId && familyData.has(currentPerson.spouseId)) {
                    const spouseOfCurrent = familyData.get(currentPerson.spouseId);
                    // Si spouseOfCurrent es hermano/a del c√≥nyuge de referencePerson
                    if (referencePerson.spouseId && familyData.has(referencePerson.spouseId)) {
                        const refSpouse = familyData.get(referencePerson.spouseId);
                        if (refSpouse && spouseOfCurrent.parentIds && refSpouse.parentIds) {
                            const commonParentsWithRefSpouse = spouseOfCurrent.parentIds.filter(pId => refSpouse.parentIds.includes(pId));
                            if (commonParentsWithRefSpouse.length > 0 && spouseOfCurrent.id !== refSpouse.id) {
                                // SpouseOfCurrent es hermano/a de refSpouse
                                // Entonces currentPerson es el c√≥nyuge del hermano/a de refSpouse
                                return currentIsMale ? 'Cu√±ado' : (currentIsFemale ? 'Cu√±ada' : 'Cu√±ado/a');
                            }
                        }
                    }
                    // O si spouseOfCurrent es c√≥nyuge de un hermano/a de referencePerson
                    if (referencePerson.parentIds && referencePerson.parentIds.length > 0) {
                        const refParents = referencePerson.parentIds.map(id => familyData.get(id)).filter(p => p);
                        for (const refParent of refParents) {
                            if (refParent.childrenIds) {
                                const siblingsOfRefPerson = refParent.childrenIds.filter(sId => sId !== referencePersonId && familyData.has(sId));
                                for (const siblingId of siblingsOfRefPerson) {
                                    const sibling = familyData.get(siblingId);
                                    if (sibling && sibling.spouseId === spouseOfCurrent.id && spouseOfCurrent.spouseId === sibling.id) {
                                        // SpouseOfCurrent es c√≥nyuge de un hermano de referencePerson
                                        // Entonces currentPerson es la pareja de mi cu√±ado/a
                                        return currentIsMale ? 'Cu√±ado' : (currentIsFemale ? 'Cu√±ada' : 'Cu√±ado/a');
                                    }
                                }
                            }
                        }
                    }
                }

                 // Nieto Pol√≠tico (pareja de mi nieto/a biol√≥gico/a)
                // currentPerson es el c√≥nyuge de X, donde X es Nieto/a biol√≥gico/a de referencePerson
                if (currentPerson.spouseId && familyData.has(currentPerson.spouseId)) {
                    const spouseOfCurrent = familyData.get(currentPerson.spouseId);
                    const distSpouseOfCurrentToRef = refDescendantsWithDist.get(spouseOfCurrent.id); // Distancia del c√≥nyuge de currentPerson a referencePerson como descendiente
                    
                    if (distSpouseOfCurrentToRef === 2) { // Si el c√≥nyuge de currentPerson es nieto/a de referencePerson
                        return currentIsMale ? 'Nieto Pol√≠tico' : (currentIsFemale ? 'Nieta Pol√≠tica' : 'Nieto/a Pol√≠tico/a');
                    }
                }

                // Bisnieto pol√≠tico (pareja de mi bisnieta)
                if (currentPerson.spouseId && familyData.has(currentPerson.spouseId)) {
                    const spouseOfCurrent = familyData.get(currentPerson.spouseId);
                    const distSpouseOfCurrentToRef = refDescendantsWithDist.get(spouseOfCurrent.id);
                    
                    if (distSpouseOfCurrentToRef === 3) { // Si el c√≥nyuge de currentPerson es bisnieto/a de referencePerson
                        return currentIsMale ? 'Bisnieto Pol√≠tico' : (currentIsFemale ? 'Bisnieta Pol√≠tica' : 'Bisnieto/a Pol√≠tico/a');
                    }
                }

                // Tataranieto Pol√≠tico (pareja de mi tataranieta)
                if (currentPerson.spouseId && familyData.has(currentPerson.spouseId)) { 
                    const spouseOfCurrent = familyData.get(currentPerson.spouseId);
                    const distSpouseOfCurrentToRef = refDescendantsWithDist.get(spouseOfCurrent.id);
                    
                    if (distSpouseOfCurrentToRef === 4) { // Si el c√≥nyuge de currentPerson es tataranieto/a de referencePerson
                        return currentIsMale ? 'Tataranieto Pol√≠tico' : (currentIsFemale ? 'Tataranieta Pol√≠tica' : 'Tataranieto/a Pol√≠tico/a');
                    }
                }


                // Si currentPerson es el c√≥nyuge de un sobrino de referencePerson
                // 1. Encuentra todos los sobrinos de referencePerson
                // 2. Comprueba si currentPerson es el c√≥nyuge de alguno de esos sobrinos
                const refSiblings = Array.from(familyData.values()).filter(p => p.parentIds && referencePerson.parentIds && p.parentIds.some(rpId => referencePerson.parentIds.includes(rpId)) && p.id !== referencePersonId);
                for (const sibling of refSiblings) {
                    const siblingChildren = Array.from(familyData.values()).filter(p => p.parentIds && p.parentIds.includes(sibling.id));
                    for (const nephew of siblingChildren) {
                        if (nephew.spouseId === currentPersonId && currentPerson.spouseId === nephew.id) {
                            return currentIsMale ? 'Sobrino Pol√≠tico' : (currentIsFemale ? 'Sobrina Pol√≠tica' : 'Sobrino/a Pol√≠tico/a');
                        }
                    }
                }
            
                // Fallback a la relaci√≥n de la DB si no se encuentra algo espec√≠fico, o 'Familiar'
                return currentPerson.relationship || 'Familiar';
            };

            const birthDate = new Date(person.dob);
                    
            // Obtener la fecha actual en horario de Santiago de Chile
            // L√≥gica para el gorrito de cumplea√±os
            let birthdayClass = '';
            if (person.dob && person.dob !== '0000-00-00') {
                try {
                    const dobParts = person.dob.split('-').map(Number); // [a√±o, mes, d√≠a]
                    const birthDateUTC = new Date(Date.UTC(dobParts[0], dobParts[1] - 1, dobParts[2] + 1 ));

                    const now = new Date();
                    const options = { timeZone: 'America/Santiago', month: 'numeric', day: 'numeric' };
                    const santiagoDate = new Intl.DateTimeFormat('es-CL', options).format(now);
                    const birthMonthDay = new Intl.DateTimeFormat('es-CL', options).format(birthDateUTC);

                    if (santiagoDate === birthMonthDay) {
                        birthdayClass = ' birthday';
                    }
                } catch (e) {
                    console.error("Error calculando cumplea√±os de la persona principal", e);
                }
            }



             let childIcon = '';
            // Calcular la edad num√©rica para la comprobaci√≥n de < 10 a√±os
            let actualAge = -1; // Inicializar con un valor que indique que no se ha calculado
            if (person.dob && person.dob !== '0000-00-00') {
                 try {
                    const birthDate = new Date(person.dob);
                    const today = new Date();
                    // Solo si est√° viva, calculamos la edad actual. Si ha fallecido, no tiene "edad actual"
                    if (!isDeceased && !isNaN(birthDate.getTime())) {
                        actualAge = today.getFullYear() - birthDate.getFullYear();
                        const m = today.getMonth() - birthDate.getMonth();
                        if (m < 0 || (m === 0 && today.getDate() < birthDate.getDate())) {
                            actualAge--;
                        }
                    } 
                 } catch(e) { /* Error calculando edad, ignorar */ }
            }

            // Si la edad calculada es menor de 10 a√±os (o si se muri√≥ antes de los 10 a√±os)
            if (actualAge >= 0 && actualAge < 10) { // Asegura que la edad es v√°lida y menor de 10
                childIcon = '<span class="icon-status icon-child">üë∂</span>'; // Beb√©
            }

            const displayRelationship = calculateDynamicRelationship(person.id, selectedPersonId);
            const mainPersonShortName = getShortName(person.name);
            const mainPersonProfilePic = getProfilePicHtml(person.photo, person.name);


            const mainPersonHtml = `
                <div class="member ${isDeceased ? ' deceased' : ''} ${birthdayClass} ${currentIsMale ? 'male' : 'female'}" data-id="${person.id}">
                    ${childIcon}
                    ${mainPersonProfilePic}
                    <div class="name">${mainPersonShortName}</div>
                    <div class="relationship">${displayRelationship}</div>
                    ${ageInTree}
                </div>
            `;

            if (person.spouseId && familyData.has(person.spouseId)) {
                const spouse = familyData.get(person.spouseId);
                if (spouse && spouse.id !== person.id && spouse.spouseId === person.id && !renderedIds.has(spouse.id)) { 
                    renderedIds.add(spouse.id); 
                    
                    let spouseAgeInTree = '';
                   if (spouse.dob && spouse.dob !== '0000-00-00') {
                        try {
                            const birthDate = new Date(spouse.dob);
                            let endDate = new Date(); // Por defecto, hoy

                            const hasDeathDate = spouse.dod && spouse.dod !== '0000-00-00';
                            if (hasDeathDate) {
                                endDate = new Date(spouse.dod);
                            }

                            if(!isNaN(birthDate.getTime()) && !isNaN(endDate.getTime())){
                                let ageDiff = endDate.getFullYear() - birthDate.getFullYear();
                                const m = endDate.getMonth() - birthDate.getMonth();
                                if (m < 0 || (m === 0 && endDate.getDate() < birthDate.getDate())) {
                                    ageDiff--;
                                }
                                if (ageDiff >= 0) {
                                    spouseAgeInTree = `<div class="age">${ageDiff} a√±os${hasDeathDate ? `${currentIsMale ? ' (fallecida)' : ' (fallecido)'}` : ''}</div>`;
                                }
                            }
                        } catch(e) { console.error("Error calculating spouse age for tree node", e); }
                    }

                    const spouseDisplayRelationship = calculateDynamicRelationship(spouse.id, selectedPersonId);
                    const spouseShortName = getShortName(spouse.name);
                    const spouseProfilePic = getProfilePicHtml(spouse.photo, spouse.name);
                    // Determinar si la pareja ha fallecido para a√±adir la clase 'deceased'
                    const isSpouseDeceased = spouse.dod && spouse.dod !== '0000-00-00';


                     let spouseBirthdayClass = '';
                        if (spouse.dob && spouse.dob !== '0000-00-00') {
                            try {
                                // MODIFICACI√ìN CLAVE AQU√ç PARA C√ìNYUGE
                                const dobPartsSpouse = spouse.dob.split('-').map(Number);
                                const birthDateSpouseUTC = new Date(Date.UTC(dobPartsSpouse[0], dobPartsSpouse[1] - 1, dobPartsSpouse[2] +1 ));
                                const now = new Date();
                                const options = { timeZone: 'America/Santiago', month: 'numeric', day: 'numeric' };
                                const santiagoDate = new Intl.DateTimeFormat('es-CL', options).format(now);
                                const birthMonthDaySpouse = new Intl.DateTimeFormat('es-CL', options).format(birthDateSpouseUTC);

                                if (santiagoDate === birthMonthDaySpouse) {
                                    spouseBirthdayClass = ' birthday';
                                }
                            } catch(e) {
                                console.error("Error calculating spouse birthday for tree node", e);
                            }
                        }


                    let spouseChildIcon = '';
                    let spouseActualAge = -1;
                    if (spouse.dob && spouse.dob !== '0000-00-00') {
                        try {
                            const birthDate = new Date(spouse.dob);
                            const today = new Date();
                            if (!isSpouseDeceased && !isNaN(birthDate.getTime())) {
                                spouseActualAge = today.getFullYear() - birthDate.getFullYear();
                                const m = today.getMonth() - birthDate.getMonth();
                                if (m < 0 || (m === 0 && today.getDate() < birthDate.getDate())) {
                                    spouseActualAge--;
                                }
                            } 
                        } catch(e) { /* Error calculando edad, ignorar */ }
                    }

                    if (spouseActualAge >= 0 && spouseActualAge < 10) {
                        spouseChildIcon = `<span class="icon-status icon-child" id="${spouse.id}">üë∂</span>`;
                    }


                    const spouseHtml = `
                        <div class="member ${isSpouseDeceased ? 'deceased' : ''} ${spouseBirthdayClass} ${currentIsMale ? 'female' : 'male'}" data-id="${spouse.id}">
                            ${spouseChildIcon}
                            ${spouseProfilePic}
                            <div class="name">${spouseShortName}</div>
                            <div class="relationship">${spouseDisplayRelationship}</div>
                            ${spouseAgeInTree}
                        </div>
                    `;
                    const spouseLine = '<div class="spouse-line"></div>';

                    if (person.id < spouse.id) {
                        nodeContent += mainPersonHtml + spouseLine + spouseHtml;
                    } else {
                        nodeContent += spouseHtml + spouseLine + mainPersonHtml;
                    }
                } else {
                    nodeContent += mainPersonHtml; 
                }
            } else {
                nodeContent += mainPersonHtml;
            }
            nodeContent += '</div>';

            let childrenHtml = '';
            
            const parentIdsOfCurrentUnit = new Set();
            parentIdsOfCurrentUnit.add(person.id);
            if (person.spouseId && familyData.has(person.spouseId) && familyData.get(person.spouseId).spouseId === person.id) {
                parentIdsOfCurrentUnit.add(person.spouseId);
            }

            const childrenOfThisFamilyUnit = Array.from(familyData.values())
                                                .filter(child => {
                                                    const childParents = child.parentIds || [];
                                                    return Array.from(parentIdsOfCurrentUnit).some(pId => childParents.includes(pId));
                                                })
                                                .filter(child => !renderedIds.has(child.id))
                                                .sort((a,b) => a.name.localeCompare(b.name));

            if (childrenOfThisFamilyUnit.length > 0) {
                childrenHtml += '<ul>';
                childrenOfThisFamilyUnit.forEach(child => {
                    childrenHtml += generatePersonHtml(child, renderedIds); 
                });
                childrenHtml += '</ul>';
            }

            return `<li>${nodeContent}${childrenHtml}</li>`;
        }


        function showPersonDetails(personId) {
            selectedPersonId = personId; 
            const person = familyData.get(personId);
            const detailsContent = document.getElementById('details-content');
            const editButtons = document.getElementById('edit-buttons');
            const editPersonLink = document.getElementById('edit-person-link');

            if (!person || !detailsContent || !editButtons || !editPersonLink) {
                detailsContent.innerHTML = '<p class="text-gray-500">Selecciona una persona para ver su informaci√≥n.</p>';
                editButtons.classList.add('hidden');
                editPersonLink.href = '#'; 
                return;
            }
            
            renderTree(); 

            document.querySelectorAll('.member').forEach(el => el.classList.remove('selected', 'highlighted', 'ancestor-spouse-highlight'));
            document.querySelectorAll('.tree li').forEach(li => li.classList.remove('highlighted-path'));
            document.querySelectorAll('.node-content').forEach(nc => nc.classList.remove('highlighted-path'));

            const currentSelectedMemberElement = document.querySelector(`.member[data-id="${personId}"]`);
            if(currentSelectedMemberElement) {
                currentSelectedMemberElement.classList.add('selected');
            }

            let queue = [personId]; 
            const visitedForHighlight = new Set(); 

            while (queue.length > 0) {
                const currentId = queue.shift(); 
                
                if (visitedForHighlight.has(currentId)) {
                    continue; 
                }
                visitedForHighlight.add(currentId); 

                const currentPerson = familyData.get(currentId);
                if (!currentPerson) {
                    continue; 
                }

                const memberElement = document.querySelector(`.member[data-id="${currentPerson.id}"]`);
                if (memberElement) {
                    memberElement.classList.add('highlighted');
                }

                if (currentPerson.spouseId && familyData.has(currentPerson.spouseId)) {
                    const spouse = familyData.get(currentPerson.spouseId);
                    if (spouse && spouse.spouseId === currentPerson.id) { 
                        const spouseElement = document.querySelector(`.member[data-id="${currentPerson.spouseId}"]`);
                        if (spouseElement) {
                            spouseElement.classList.add('ancestor-spouse-highlight');
                        }
                        const nodeContentElement = memberElement ? memberElement.closest('.node-content') : null;
                        if (nodeContentElement) {
                            nodeContentElement.classList.add('highlighted-path');
                        }
                    }
                }
                
                const liElement = memberElement ? memberElement.closest('li') : null;
                if (liElement) {
                    liElement.classList.add('highlighted-path');
                }

                const parentsOfCurrentPerson = Array.from(familyData.values())
                    .filter(p => p.childrenIds && p.childrenIds.includes(currentId));

                parentsOfCurrentPerson.forEach(parent => {
                    if (!visitedForHighlight.has(parent.id) && familyData.has(parent.id)) {
                        queue.push(parent.id);
                    }
                });
            }


            let age = '';
            let ageAtDeath = '';
            let ageAtMarriage = ''; // Variable para la edad al matrimonio

            if(person.dob){
                try {
                    const birthDate = new Date(person.dob);
                    const endDate = person.dod && person.dod !== '0000-00-00' ? new Date(person.dod) : new Date();
                    if(!isNaN(birthDate.getTime())){
                        let ageDiff = endDate.getFullYear() - birthDate.getFullYear();
                        const m = endDate.getMonth() - birthDate.getMonth();
                        if (m < 0 || (m === 0 && today.getDate() < birthDate.getDate())) {
                            ageDiff--;
                        }
                        if(person.dod && person.dod !== '0000-00-00') {
                            ageAtDeath = `(falleci√≥ a los ${ageDiff} a√±os)`;
                        } else if (ageDiff >= 0) { 
                            age = `${ageDiff} a√±os`;
                        }
                    }
                } catch(e) { console.error("Error calculating age", e); }
            }

            // L√≥gica para edad al matrimonio
            if (person.dob && person.dom && person.dob !== '0000-00-00' && person.dom !== '0000-00-00') {
                try {
                    const birthDate = new Date(person.dob);
                    const marriageDate = new Date(person.dom);
                    if (!isNaN(birthDate.getTime()) && !isNaN(marriageDate.getTime())) {
                        let ageDiff = marriageDate.getFullYear() - birthDate.getFullYear();
                        const m = marriageDate.getMonth() - birthDate.getMonth();
                        if (m < 0 || (m === 0 && marriageDate.getDate() < birthDate.getDate())) {
                            ageDiff--;
                        }
                        if (ageDiff >= 0) {
                            ageAtMarriage = `(se cas√≥ a los ${ageDiff} a√±os)`;
                        }
                    }
                } catch(e) { console.error("Error calculating age at marriage", e); }
            }
            
            const formatDate = (dateString) => {
                if (!dateString || dateString === '0000-00-00') return 'No disponible';
                try {
                    const date = new Date(dateString);
                    const adjustedDate = new Date(date.getTime() + date.getTimezoneOffset() * 60000); 
                    if(isNaN(adjustedDate.getTime())) return 'Fecha inv√°lida';
                    const options = { year: 'numeric', month: 'long', day: 'numeric' };
                    return adjustedDate.toLocaleDateString('es-ES', options);
                } catch(e) {
                    return 'Fecha inv√°lida';
                }
            };

            detailsContent.innerHTML = `
                <img src="${person.photo || 'https://placehold.co/120x120/E2E8F0/333333?text=Foto'}" alt="Foto de ${person.name}" class="w-24 h-24 md:w-32 md:h-32 rounded-full mx-auto mb-4 object-cover border-4 border-white shadow-md" onerror="this.onerror=null;this.src='https://placehold.co/120x120/E2E8F0/333333?text=Foto';">
                <h3 class="text-xl font-bold">${person.name}</h3>
                <p class="text-sm text-gray-500 mb-4">${person.relationship || ''}</p>
                <div class="text-left space-y-2">
                    <p><strong>G√©nero:</strong> ${person.gender || 'No disponible'}</p>
                    <p><strong>RUT:</strong> ${person.rut || 'No disponible'}</p>
                    <p><strong>Nacimiento:</strong> ${formatDate(person.dob)}</p>
                    ${age ? `<p><strong>Edad:</strong> ${age}</p>` : ''}
                    <p><strong>Matrimonio:</strong> ${formatDate(person.dom)} ${ageAtMarriage}</p>
                    <p><strong>Fallecimiento:</strong> ${formatDate(person.dod)} ${ageAtDeath}</p>
                </div>
            `;
            editButtons.classList.remove('hidden');

            editPersonLink.href = `editar.php?id=${personId}`;
        }

        const modal = document.getElementById('person-modal');
        const form = document.getElementById('person-form');
        const cancelBtn = document.getElementById('cancel-btn');
        const relationshipsModal = document.getElementById('relationships-modal');
        const relationshipPersonNameSpan = document.getElementById('relationship-person-name');
        const currentSpouseDisplay = document.getElementById('current-spouse-display');
        const currentParentsList = document.getElementById('current-parents-list');
        const currentChildrenList = document.getElementById('current-children-list');
        const addNewSpouseBtn = document.getElementById('add-new-spouse-btn'); 
        const linkExistingSpouseBtn = document.getElementById('link-existing-spouse-btn');
        const addNewParentBtn = document.getElementById('add-new-parent-btn'); 
        const linkExistingParentBtn = document.getElementById('link-existing-parent-btn');
        const addNewChildBtn = document.getElementById('add-new-child-btn'); 
        const linkExistingChildBtn = document.getElementById('link-existing-child-btn');

        const closeRelationshipsModalBtn = document.getElementById('close-relationships-modal-btn');

        const selectPersonModal = document.getElementById('select-person-modal');
        const selectModalTitle = document.getElementById('select-modal-title');
        const personSearchInput = document.getElementById('person-search-input');
        const personListContainer = document.getElementById('person-list-container');
        const cancelSelectPersonBtn = document.getElementById('cancel-select-person-btn');


        function openPersonModal(mode, personId = null) {
            modalMode = mode; 
            relatedPersonId = personId; 
            relatedPersonSpouseId = null; 
            
            const formTitle = document.getElementById('modal-title');
            const personIdField = form.querySelector('#person-id'); 

            form.reset();
            personIdField.value = ''; 

            if (mode.startsWith('add_') && personId !== null) {
                const selectedPerson = familyData.get(personId);
                if (!selectedPerson) return; 
                relatedPersonSpouseId = selectedPerson.spouseId; 
                
                if (mode === 'add_descendant') {
                    formTitle.innerText = `Agregar Hijo/a a ${selectedPerson.name}`;
                    form.querySelector('#relationship').value = 'Hijo/a'; 
                } else if (mode === 'add_ancestor') {
                    formTitle.innerText = `Agregar Padre/Madre a ${selectedPerson.name}`;
                    form.querySelector('#relationship').value = 'Padre/Madre'; 
                } else if (mode === 'add_spouse') {
                    formTitle.innerText = `Agregar C√≥nyuge a ${selectedPerson.name}`;
                    form.querySelector('#relationship').value = 'C√≥nyuge'; 
                }
            }
            
            modal.classList.remove('hidden');
        }

        async function openRelationshipsModal(personId) {
            selectedPersonId = personId; 
            const person = familyData.get(personId);
            if (!person) return;

            relationshipPersonNameSpan.innerText = person.name;

            currentSpouseDisplay.innerHTML = '';
            currentParentsList.innerHTML = '';
            currentChildrenList.innerHTML = '';

            if (person.spouseId && familyData.has(person.spouseId)) {
                const spouse = familyData.get(person.spouseId);
                if (spouse.spouseId === person.id) {
                    currentSpouseDisplay.innerHTML = `
                        <span class="font-semibold">${spouse.name}</span>
                        <button class="remove-relationship-btn text-red-500 hover:text-red-700 text-sm" 
                                data-action="remove_spouse" 
                                data-person-id="${person.id}">Eliminar V√≠nculo</button>
                    `;
                } else {
                    currentSpouseDisplay.innerHTML = '<p class="text-gray-500">No hay c√≥nyuge rec√≠proco asignado.</p>';
                }
            } else {
                currentSpouseDisplay.innerHTML = '<p class="text-gray-500">No hay c√≥nyuge asignado.</p>';
            }

            if (person.parentIds && person.parentIds.length > 0) {
                person.parentIds.sort((a,b) => familyData.get(a)?.name.localeCompare(familyData.get(b)?.name) || 0).forEach(parentId => {
                    const parent = familyData.get(parentId);
                    if (parent) {
                        const div = document.createElement('div');
                        div.className = 'flex items-center justify-between p-2 bg-gray-100 rounded-md border border-gray-200';
                        div.innerHTML = `
                            <span class="font-semibold">${parent.name}</span>
                            <button class="remove-relationship-btn text-red-500 hover:text-red-700 text-sm" 
                                    data-action="remove_parent_child" 
                                    data-parent-id="${parentId}" 
                                    data-child-id="${person.id}">Eliminar V√≠nculo</button>
                        `;
                        currentParentsList.appendChild(div);
                    }
                });
            } else {
                currentParentsList.innerHTML = '<p class="text-gray-500">No hay padres asignados.</p>';
            }

            let childrenOfThisPersonAndSpouse = new Set();
            if (person.childrenIds) {
                person.childrenIds.forEach(childId => childrenOfThisPersonAndSpouse.add(childId));
            }
            if (person.spouseId && familyData.has(person.spouseId) && familyData.get(person.spouseId).spouseId === person.id) {
                const spouse = familyData.get(person.spouseId);
                if (spouse.childrenIds) {
                    spouse.childrenIds.forEach(childId => childrenOfThisPersonAndSpouse.add(childId));
                }
            }

            const childrenToShow = Array.from(childrenOfThisPersonAndSpouse)
                                        .map(id => familyData.get(id))
                                        .filter(child => child !== undefined) 
                                        .filter(child => {
                                            const childParents = child.parentIds || [];
                                            const isChildOfThisPerson = childParents.includes(person.id);
                                            
                                            let isChildOfSpouse = false;
                                            if (person.spouseId && familyData.has(person.spouseId) && familyData.get(person.spouseId).spouseId === person.id) {
                                                isChildOfSpouse = childParents.includes(person.spouseId);
                                            }
                                            return isChildOfThisPerson || isChildOfSpouse;
                                        })
                                        .sort((a,b) => a.name.localeCompare(b.name));
            
            if (childrenToShow.length > 0) {
                currentChildrenList.innerHTML = ''; 
                childrenToShow.forEach(child => {
                    const div = document.createElement('div');
                    div.className = 'flex items-center justify-between p-2 bg-gray-100 rounded-md border border-gray-200';
                    div.innerHTML = `
                        <span class="font-semibold">${child.name}</span>
                        <button class="remove-relationship-btn text-red-500 hover:text-red-700 text-sm" 
                                data-action="remove_parent_child" 
                                data-parent-id="${person.id}" 
                                data-child-id="${child.id}">Eliminar V√≠nculo</button>
                    `;
                    currentChildrenList.appendChild(div);
                });
            } else {
                 currentChildrenList.innerHTML = '<p class="text-gray-500">No hay hijos/as asignados.</p>';
            }

            relationshipsModal.classList.remove('hidden');
        }

         function openSelectPersonModal(mode, currentPersonId) {
            selectPersonMode = mode;
            personToLinkToId = currentPersonId; 

            if (mode === 'link_spouse') {
                selectModalTitle.innerText = `Seleccionar C√≥nyuge para ${familyData.get(currentPersonId)?.name}`;
            } else if (mode === 'link_parent') {
                selectModalTitle.innerText = `Seleccionar Padre/Madre para ${familyData.get(currentPersonId)?.name}`;
            } else if (mode === 'link_child') {
                selectModalTitle.innerText = `Seleccionar Hijo/a para ${familyData.get(currentPersonId)?.name}`;
            }

            renderSelectablePeopleList(personSearchInput.value, currentPersonId); 
            personSearchInput.value = ''; 
            personSearchInput.focus();

            selectPersonModal.classList.remove('hidden');
        }

        function renderSelectablePeopleList(searchTerm = '', excludeId = null) {
            personListContainer.innerHTML = '';
            const filteredPeople = Array.from(familyData.values()).filter(p => 
                p.id !== excludeId && 
                p.name.toLowerCase().includes(searchTerm.toLowerCase())
            ).sort((a,b) => a.name.localeCompare(b.name));

            if (filteredPeople.length === 0) {
                personListContainer.innerHTML = '<p class="p-3 text-gray-500 text-center">No se encontraron personas.</p>';
                return;
            }

            filteredPeople.forEach(person => {
                const div = document.createElement('div');
                div.className = 'p-3 border-b border-gray-100 cursor-pointer hover:bg-blue-50 transition duration-150';
                div.dataset.personId = person.id; 
                div.innerText = `${person.name}`;
                personListContainer.appendChild(div);
            });
        }
        
        document.getElementById('manage-relationships-btn').addEventListener('click', () => {
            if (selectedPersonId) {
                openRelationshipsModal(selectedPersonId);
            } else {
                alert('Selecciona una persona para gestionar sus relaciones.');
            }
        });

        closeRelationshipsModalBtn.addEventListener('click', () => {
            relationshipsModal.classList.add('hidden');
            if (selectedPersonId) {
                showPersonDetails(selectedPersonId);
            }
            loadFamilyData(); 
        });

        addNewSpouseBtn.addEventListener('click', () => {
            if (selectedPersonId) {
                relationshipsModal.classList.add('hidden'); 
                openPersonModal('add_spouse', selectedPersonId); 
            }
        });

        addNewParentBtn.addEventListener('click', () => {
           if (selectedPersonId) {
                relationshipsModal.classList.add('hidden'); 
                openPersonModal('add_ancestor', selectedPersonId); 
            }
        });

        addNewChildBtn.addEventListener('click', () => {
            if (selectedPersonId) {
                relationshipsModal.classList.add('hidden'); 
                openPersonModal('add_descendant', selectedPersonId); 
            }
        });

        linkExistingSpouseBtn.addEventListener('click', () => {
            if (selectedPersonId) {
                openSelectPersonModal('link_spouse', selectedPersonId);
            }
        });

        linkExistingParentBtn.addEventListener('click', () => {
            if (selectedPersonId) {
                openSelectPersonModal('link_parent', selectedPersonId); 
            }
        });

        linkExistingChildBtn.addEventListener('click', () => {
            if (selectedPersonId) {
                openSelectPersonModal('link_child', selectedPersonId); 
            }
        });

        relationshipsModal.addEventListener('click', async (event) => {
            if (event.target.classList.contains('remove-relationship-btn')) {
                const button = event.target;
                const action = button.dataset.action;
                let dataToSend = { _action: action };

                if (action === 'remove_parent_child') {
                    dataToSend.parent_id = parseInt(button.dataset.parentId);
                    dataToSend.child_id = parseInt(button.dataset.childId);
                    if (!confirm(`¬øEst√°s seguro de que quieres eliminar el v√≠nculo de padre/madre entre ${familyData.get(dataToSend.parent_id)?.name} y ${familyData.get(dataToSend.child_id)?.name}?`)) {
                        return;
                    }
                } else if (action === 'remove_spouse') {
                    dataToSend.person_id = parseInt(button.dataset.personId);
                    if (!confirm(`¬øEst√°s seguro de que quieres eliminar el v√≠nculo de c√≥nyuge de ${familyData.get(dataToSend.person_id)?.name}? Esto tambi√©n desvincular√° a su c√≥nyuge.`)) {
                        return;
                    }
                } else {
                    return; 
                }

                const result = await sendDataToAPI(dataToSend);
                if (result && result.success) {
                    openRelationshipsModal(selectedPersonId); 
                    loadFamilyData();
                }
            }
        });

        
        form.addEventListener('submit', async (event) => {
            event.preventDefault();

            const personData = {
                name: form.querySelector('#name').value,
                relationship: form.querySelector('#relationship').value,
                rut: form.querySelector('#rut').value,
                gender: form.querySelector('#gender').value,
                dob: form.querySelector('#dob').value,
                dom: form.querySelector('#dom').value,
                dod: form.querySelector('#dod').value,
                photo: form.querySelector('#photo').value,
            };

            let actionData = { _action: modalMode, personData: personData };

            actionData.selectedPersonId = relatedPersonId;
            if (modalMode === 'add_descendant') {
                actionData.selectedPersonSpouseId = relatedPersonSpouseId;
            }

            const result = await sendDataToAPI(actionData);
            if (result && result.success) {
                modal.classList.add('hidden');
                if (result.new_person_id) { 
                    showPersonDetails(result.new_person_id);
                } else if (relatedPersonId) {
                    showPersonDetails(relatedPersonId);
                }
            }
        });

        cancelBtn.addEventListener('click', () => {
             modal.classList.add('hidden');
             if (relationshipsModal.classList.contains('hidden') && selectedPersonId) {
                 openRelationshipsModal(selectedPersonId);
             }
        });

        personSearchInput.addEventListener('input', (event) => {
            renderSelectablePeopleList(event.target.value, personToLinkToId); 
        });

        personListContainer.addEventListener('click', async (event) => {
            const selectedElement = event.target.closest('div[data-person-id]');
            if (selectedElement) {
                const targetPersonId = parseInt(selectedElement.dataset.personId);
                let dataToSend = {};

                if (selectPersonMode === 'link_spouse') {
                    dataToSend = {
                        _action: 'link_existing_spouse',
                        person1_id: personToLinkToId,
                        person2_id: targetPersonId
                    };
                } else if (selectPersonMode === 'link_parent') {
                    dataToSend = {
                        _action: 'link_existing_parent_child',
                        parent_id: targetPersonId, 
                        child_id: personToLinkToId 
                    };
                } else if (selectPersonMode === 'link_child') {
                    dataToSend = {
                        _action: 'link_existing_parent_child',
                        parent_id: personToLinkToId, 
                        child_id: targetPersonId 
                    };
                }

                const result = await sendDataToAPI(dataToSend);
                if (result && result.success) {
                    selectPersonModal.classList.add('hidden');
                    relationshipsModal.classList.add('hidden'); 
                    showPersonDetails(selectedPersonId); 
                    loadFamilyData(); 
                }
            }
        });

        cancelSelectPersonBtn.addEventListener('click', () => {
            selectPersonModal.classList.add('hidden');
            if (selectedPersonId) {
                openRelationshipsModal(selectedPersonId);
            }
        });

        document.getElementById('add-descendant-btn').addEventListener('click', () => {
            if (selectedPersonId) {
                openPersonModal('add_descendant', selectedPersonId);
            }
        });

        document.getElementById('add-ancestor-btn').addEventListener('click', () => {
            if (selectedPersonId) {
                openPersonModal('add_ancestor', selectedPersonId);
            }
        });

        function addClickListeners() {
            document.querySelectorAll('.member').forEach(element => {
                element.addEventListener('click', (event) => {
                    event.stopPropagation();
                    const personId = parseInt(event.currentTarget.dataset.id);
                    showPersonDetails(personId);
                });
            });
        }
        
        document.addEventListener('DOMContentLoaded', () => {
            loadFamilyData();

            const detailsHeader = document.getElementById('details-header');
            const mainLayout = document.getElementById('main-layout');

           if (detailsHeader && mainLayout) {
                detailsHeader.addEventListener('click', () => {
                    // Alterna la clase 'aside-collapsed' en el contenedor padre
                    mainLayout.classList.toggle('aside-collapsed');
                });
            }
        });
// ----------------------------------------------------------------------
        // FUNCI√ìN DE EXPORTACI√ìN DEL √ÅRBOL
        // ----------------------------------------------------------------------
        function exportTree(format) {
            // El selector '.tree' apunta al contenedor flexible interno que realmente se estira
            const treeElement = document.querySelector('.tree'); 
            
            if (!treeElement) {
                alert("No se encontr√≥ el contenido del √°rbol para exportar.");
                return;
            }

            // Muestra un mensaje de carga (opcional, pero √∫til)
            // const originalHtml = treeElement.innerHTML;
            // treeElement.innerHTML = '<div class="text-center p-10">Generando exportaci√≥n... Por favor, espere.</div>';

            // Opciones para la captura de alta resoluci√≥n
            const options = {
                scale: 3, // Factor de escala para alta resoluci√≥n (3x)
                useCORS: true,
                logging: false,
                backgroundColor: '#f0f2f5' // El color de fondo de tu cuerpo
            };

            html2canvas(treeElement, options).then(canvas => {
                // treeElement.innerHTML = originalHtml; // Restaura el contenido (si se us√≥ mensaje de carga)
                
                if (format === 'png') {
                    // Exportar como PNG
                    const imageURL = canvas.toDataURL('image/png');
                    const link = document.createElement('a');
                    link.href = imageURL;
                    link.download = `arbol_genealogico_${selectedPersonId || 'completo'}.png`;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);

                } else if (format === 'pdf') {
                    // Exportar como PDF (maneja √°rboles grandes/anchos)
                    const { jsPDF } = window.jspdf;
                    const imgData = canvas.toDataURL('image/jpeg', 1.0); // Calidad JPEG para PDF
                    
                    const canvasWidth = canvas.width;
                    const canvasHeight = canvas.height;
                    
                    // Tama√±o de la p√°gina PDF (ajustado para ser ancho)
                    const pdfWidth = 297; // Ancho A4 en mm (se rotar√°)
                    const pdfHeight = (canvasHeight * pdfWidth) / canvasWidth; // Calcula la altura proporcional
                    
                    // Inicializa jsPDF en formato apaisado (landscape)
                    const pdf = new jsPDF({
                        orientation: canvasWidth > canvasHeight ? 'l' : 'p', // 'l' = landscape (horizontal)
                        unit: 'mm',
                        format: [pdfWidth, pdfHeight] // Usa el tama√±o calculado para evitar el escalado.
                    });

                    // A√±ade la imagen al PDF, cubriendo toda el √°rea.
                    pdf.addImage(imgData, 'JPEG', 0, 0, pdfWidth, pdfHeight);
                    pdf.save(`arbol_genealogico_${selectedPersonId || 'completo'}.pdf`);
                }
            });
        }

        // ----------------------------------------------------------------------
        // CONECTAR BOTONES AL EVENT LISTENER
        // ----------------------------------------------------------------------
        document.addEventListener('DOMContentLoaded', () => {
            // ... (Tu c√≥digo existente para loadFamilyData, etc.) ...
            
            // Conectar botones de exportaci√≥n
            const exportPngBtn = document.getElementById('export-tree-png');
            const exportPdfBtn = document.getElementById('export-tree-pdf');

            if (exportPngBtn) {
                exportPngBtn.addEventListener('click', () => exportTree('png'));
            }
            if (exportPdfBtn) {
                exportPdfBtn.addEventListener('click', () => exportTree('pdf'));
            }
        });
    </script>
</body>
</html>