<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Árbol Genealógico Interactivo</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f2f5;
        }
        /* --- ESTILOS MEJORADOS PARA EL ÁRBOL GENEALÓGICO --- */
        .tree-container {
            width: 100%;
            overflow-x: auto;
            padding: 1em;
        }

        .tree {
            display: inline-flex; /* Clave para que el contenedor se ajuste al contenido y permita scroll */
            flex-direction: column;
            align-items: center;
            min-width: 100%;
        }

        .tree ul {
            position: relative;
            padding-top: 20px;
            display: flex;
            justify-content: center;
        }

        .member .profile-pic {
            width: 60px; /* Tamaño de la imagen */
            height: 60px;
            border-radius: 50%; /* Hacer la imagen redonda */
            object-fit: cover; /* Asegurar que la imagen cubra el área sin distorsionarse */
            border: 2px solid #ddd; /* Pequeño borde */
            margin-bottom: 5px; /* Margen debajo de la imagen y el nombre */
            box-shadow: 0 2px 4px rgba(0,0,0,0.1); /* Sombra suave */
            margin: 0 auto;
        }

        .tree li {
            list-style-type: none;
            position: relative;
            padding: 20px 5px 0 5px;
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        /* --- Conectores --- */
        /* Línea vertical hacia abajo desde el nodo */
        .tree li::before, .tree li::after {
            content: '';
            position: absolute;
            top: 0;
            right: 50%;
            border-top: 2px solid #ccc;
            width: 50%;
            height: 20px;
        }

        /* Línea horizontal */
        .tree li::after {
            right: auto;
            left: 50%;
            border-left: 2px solid #ccc;
        }

        /* Ocultar conectores innecesarios para nodos únicos */
        .tree li:only-child::after, .tree li:only-child::before {
            display: none;
        }

        .tree li:only-child {
            padding-top: 0;
        }

        /* Eliminar borde izquierdo del primer hijo y derecho del último */
        .tree li:first-child::before, .tree li:last-child::after {
            border: 0 none;
        }

        /* Conector derecho para el último hijo */
        .tree li:last-child::before {
            border-right: 2px solid #ccc;
            border-radius: 0 5px 0 0;
        }

        /* Conector izquierdo para el primer hijo */
        .tree li:first-child::after {
            border-radius: 5px 0 0 0;
        }

        /* Conector vertical para la lista de hijos */
        .tree ul ul::before {
            content: '';
            position: absolute;
            top: 0;
            left: 50%;
            border-left: 2px solid #ccc;
            width: 0;
            height: 20px;
        }
        
        /* Ocultar líneas que suben desde los nodos raíz */
        .tree > ul > li::before, .tree > ul > li::after {
             display: none;
        }

        .node-content {
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative; /* Para la línea del cónyuge */
        }

        .member {
            border: 2px solid #ccc;
            padding: 10px 15px;
            text-decoration: none;
            display: inline-block;
            border-radius: 8px;
            transition: all 0.3s;
            cursor: pointer;
            background-color: #fff;
            min-width: 140px;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            display: flex; /* Usar flexbox para alinear contenido */
            flex-direction: column; /* Apilar elementos verticalmente */
            align-items: center; /* Centrar horizontalmente */
        }

        .tree li .member:hover, .tree li .member.selected {
            background-color: #e0f2fe;
            border-color: #0ea5e9;
            transform: translateY(-2px);
            box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        .member .name {
            font-weight: 600;
            margin-top: 5px; /* Espacio entre la imagen y el nombre */
        }

        .member .relationship {
            font-size: 0.8em;
            color: #666;
        }

        .member .age {
            font-size: 0.7em; /* Un poco más pequeña que la relación */
            color: #999;
            margin-top: 0.2em; /* Pequeño margen superior */
        }
        
        /* Línea que une a los cónyuges */
        .spouse-line {
            height: 2px;
            width: 20px; /* Ancho de la línea */
            background-color: #ccc;
        }

        /* Estilos para el panel de detalles para que sea sticky y responsivo */
        @media (min-width: 1024px) { /* lg breakpoint */
            .sticky-lg {
                position: sticky;
                top: 2rem; /* Distancia desde la parte superior */
            }
        }

        /* --- ESTILOS PARA RESALTADO DE ANCESTROS (Mantenidos) --- */
        .member.highlighted {
            background-color: #d1fae5; /* Un verde claro */
            border-color: #10b981; /* Borde verde más oscuro */
            box-shadow: 0 4px 6px -1px rgba(16, 185, 129, 0.2), 0 2px 4px -2px rgba(16, 185, 129, 0.1);
        }

        /* Resaltar las líneas de conexión de los ancestros */
        .highlighted-path::before,
        .highlighted-path::after {
            border-color: #10b981 !important; /* Mismo verde que el nodo */
        }
        /* Para la línea vertical que une la lista de hijos (de la pareja resaltada) */
        .tree li.highlighted-path ul::before {
            border-left-color: #10b981 !important;
        }

        /* Asegurarse de que el cónyuge de un ancestro también tenga la línea resaltada */
        .node-content.highlighted-path .spouse-line {
            background-color: #10b981 !important;
        }
        
        /* Para asegurar que el cónyuge del ancestro directo también se vea resaltado visualmente */
        .member.ancestor-spouse-highlight {
            background-color: #d1fae5; /* Mismo verde para el cónyuge del ancestro */
            border-color: #10b981;
            box-shadow: 0 4px 6px -1px rgba(16, 185, 129, 0.2), 0 2px 4px -2px rgba(16, 185, 129, 0.1);
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">

    <div class="mx-auto p-4 md:p-8">
        <header class="mb-8 relative"> 
            <div class="flex justify-between items-start"> 
                <div class="flex-grow"></div> 
                
                <div class="text-center"> 
                    <h1 class="text-3xl md:text-5xl font-bold text-gray-800">Árbol Genealógico Familiar</h1>
                    <p class="text-gray-600 mt-2">Un vistazo a nuestras raíces y nuestra historia.</p>
                </div>

                <div class="flex-grow text-right">
                    <a href="buscar.html" class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-lg whitespace-nowrap transition duration-300 ease-in-out transform hover:-translate-y-1">Buscar Personas</a>
                </div>
            </div>
        </header>
        <div class="flex flex-col lg:flex-row gap-8">
            <main class="w-full lg:w-3/4 bg-white p-6 rounded-lg shadow-lg">
                <div id="family-tree-container" class="tree-container">
                    <div class="tree">
                        </div>
                </div>
            </main>

            <aside class="w-full lg:w-1/4">
                <div id="details-panel" class="bg-white p-6 rounded-lg shadow-lg sticky-lg">
                    <h2 class="text-2xl font-bold mb-4 border-b pb-2 text-center">Detalles de la Persona</h2>
                    <div id="details-content" class="text-center">
                        <p class="text-gray-500">Selecciona una persona para ver su información.</p>
                    </div>
                    <div id="edit-buttons" class="mt-6 hidden">
                        <button id="add-descendant-btn" class="w-full bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg mb-2 transition duration-300 ease-in-out transform hover:-translate-y-1">Agregar Descendencia</button>
                        <button id="add-ancestor-btn" class="w-full bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg mb-2 transition duration-300 ease-in-out transform hover:-translate-y-1">Agregar Ascendencia</button>
                        <button id="manage-relationships-btn" class="w-full bg-orange-500 hover:bg-orange-600 text-white font-bold py-2 px-4 rounded-lg mb-2 transition duration-300 ease-in-out transform hover:-translate-y-1">Gestionar Relaciones</button> 
                         <a id="edit-person-link" href="#" class="w-full text-center bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-2 px-4 rounded-lg block transition duration-300 ease-in-out transform hover:-translate-y-1">Editar Persona</a>
                    </div>
                </div>
            </aside>
        </div>
    </div>
    
    <div id="person-modal" class="fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full hidden z-50 flex items-center justify-center p-4">
      <div class="relative top-0 mx-auto p-5 border w-full max-w-lg shadow-lg rounded-md bg-white animate-fade-in-up">
        <div class="mt-3">
          <h3 class="text-lg leading-6 font-medium text-gray-900 mb-4" id="modal-title">Agregar Persona</h3>
          <form id="person-form">
            <input type="hidden" id="person-id"> 
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
              <input class="w-full bg-gray-100 text-gray-900 mt-2 p-3 rounded-lg focus:outline-none focus:shadow-outline focus:border-blue-500 border border-gray-200 transition duration-200" type="text" id="name" placeholder="Nombre Completo*" required>
              <input class="w-full bg-gray-100 text-gray-900 mt-2 p-3 rounded-lg focus:outline-none focus:shadow-outline focus:border-blue-500 border border-gray-200 transition duration-200" type="text" id="relationship" placeholder="Relación (Ej: Tío, Prima)">
              <input class="w-full bg-gray-100 text-gray-900 mt-2 p-3 rounded-lg focus:outline-none focus:shadow-outline focus:border-blue-500 border border-gray-200 transition duration-200" type="text" id="rut" placeholder="RUT">
              <select id="gender" class="w-full bg-gray-100 text-gray-900 mt-2 p-3 rounded-lg focus:outline-none focus:shadow-outline focus:border-blue-500 border border-gray-200 transition duration-200">
                <option value="Masculino">Masculino</option>
                <option value="Femenino">Femenino</option>
                <option value="Otro">Otro</option>
              </select>
              <input class="w-full bg-gray-100 text-gray-900 mt-2 p-3 rounded-lg focus:outline-none focus:shadow-outline focus:border-blue-500 border border-gray-200 transition duration-200" type="text" onfocus="(this.type='date')" onblur="(this.type='text')" id="dob" placeholder="Fecha de Nacimiento">
              <input class="w-full bg-gray-100 text-gray-900 mt-2 p-3 rounded-lg focus:outline-none focus:shadow-outline focus:border-blue-500 border border-gray-200 transition duration-200" type="text" onfocus="(this.type='date')" onblur="(this.type='text')" id="dom" placeholder="Fecha de Matrimonio">
              <input class="w-full bg-gray-100 text-gray-900 mt-2 p-3 rounded-lg focus:outline-none focus:shadow-outline focus:border-blue-500 border border-gray-200 transition duration-200" type="text" onfocus="(this.type='date')" onblur="(this.type='text')" id="dod" placeholder="Fecha de Fallecimiento">
              <input class="w-full bg-gray-100 text-gray-900 mt-2 p-3 rounded-lg focus:outline-none focus:shadow-outline focus:border-blue-500 border border-gray-200 transition duration-200" type="text" id="photo" placeholder="URL de la Foto">
            </div>
            
            <div class="mt-6 flex justify-end gap-4">
              <button type="button" id="cancel-btn" class="px-4 py-2 bg-gray-200 text-gray-800 rounded-md hover:bg-gray-300 transition duration-300 ease-in-out">Cancelar</button>
              <button type="submit" class="px-4 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 transition duration-300 ease-in-out">Guardar</button>
            </div>
          </form>
        </div>
      </div>
    </div>

    <div id="relationships-modal" class="fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full hidden z-50 flex items-center justify-center p-4">
        <div class="relative top-0 mx-auto p-5 border w-full max-w-2xl shadow-lg rounded-md bg-white animate-fade-in-up">
            <div class="mt-3">
                <h3 class="text-lg leading-6 font-medium text-gray-900 mb-4">Gestionar Relaciones de <span id="relationship-person-name" class="font-bold"></span></h3>
                
                <div class="space-y-4">
                    <div>
                        <h4 class="text-md font-semibold mb-2 text-gray-700">Cónyuge</h4>
                        <div id="current-spouse-display" class="flex items-center justify-between p-3 bg-gray-100 rounded-md border border-gray-200">
                            <p class="text-gray-500">No hay cónyuge asignado.</p>
                        </div>
                        <div class="mt-2 flex gap-2">
                            <button id="add-new-spouse-btn" class="px-4 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 text-sm transition duration-300 ease-in-out">Agregar Nuevo</button>
                            <button id="link-existing-spouse-btn" class="px-4 py-2 bg-purple-500 text-white rounded-md hover:bg-purple-600 text-sm transition duration-300 ease-in-out">Vincular Existente</button>
                        </div>
                    </div>

                    <div>
                        <h4 class="text-md font-semibold mb-2 text-gray-700">Padres</h4>
                        <div id="current-parents-list" class="space-y-2">
                            <p class="text-gray-500">No hay padres asignados.</p>
                        </div>
                        <div class="mt-2 flex gap-2">
                            <button id="add-new-parent-btn" class="px-4 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 text-sm transition duration-300 ease-in-out">Agregar Nuevo</button>
                            <button id="link-existing-parent-btn" class="px-4 py-2 bg-purple-500 text-white rounded-md hover:bg-purple-600 text-sm transition duration-300 ease-in-out">Vincular Existente</button>
                        </div>
                    </div>

                    <div>
                        <h4 class="text-md font-semibold mb-2 text-gray-700">Hijos/as</h4>
                        <div id="current-children-list" class="space-y-2">
                            <p class="text-gray-500">No hay hijos/as asignados.</p>
                        </div>
                        <div class="mt-2 flex gap-2">
                            <button id="add-new-child-btn" class="px-4 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 text-sm transition duration-300 ease-in-out">Agregar Nuevo</button>
                            <button id="link-existing-child-btn" class="px-4 py-2 bg-purple-500 text-white rounded-md hover:bg-purple-600 text-sm transition duration-300 ease-in-out">Vincular Existente</button>
                        </div>
                    </div>
                </div>

                <div class="mt-6 flex justify-end">
                    <button type="button" id="close-relationships-modal-btn" class="px-4 py-2 bg-gray-200 text-gray-800 rounded-md hover:bg-gray-300 transition duration-300 ease-in-out">Cerrar</button>
                </div>
            </div>
        </div>
    </div>

    <div id="select-person-modal" class="fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full hidden z-50 flex items-center justify-center p-4">
        <div class="relative top-0 mx-auto p-5 border w-full max-w-md shadow-lg rounded-md bg-white animate-fade-in-up">
            <div class="mt-3">
                <h3 class="text-lg leading-6 font-medium text-gray-900 mb-4" id="select-modal-title">Seleccionar Persona</h3>
                <input type="text" id="person-search-input" placeholder="Buscar por nombre..." class="w-full bg-gray-100 text-gray-900 p-2 rounded-lg focus:outline-none focus:shadow-outline focus:border-blue-500 border border-gray-200 transition duration-200 mb-4">
                <div id="person-list-container" class="max-h-60 overflow-y-auto border border-gray-200 rounded-md">
                    </div>
                <div class="mt-4 flex justify-end">
                    <button type="button" id="cancel-select-person-btn" class="px-4 py-2 bg-gray-200 text-gray-800 rounded-md hover:bg-gray-300 transition duration-300 ease-in-out">Cancelar</button>
                </div>
            </div>
        </div>
    </div>


    <script type="module">
        let familyData = new Map();
        let selectedPersonId = null;
        let modalMode = ''; 
        let relatedPersonId = null; 
        let relatedPersonSpouseId = null; 

        let selectPersonMode = ''; 
        let personToLinkToId = null; 


        const API_URL = 'api.php';

       
        async function loadFamilyData() {
            try {
                const response = await fetch(API_URL, {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = await response.json();
                
                familyData.clear();
                data.forEach(person => {
                    person.id = parseInt(person.id);
                    person.spouseId = person.spouse_id !== null ? parseInt(person.spouse_id) : null;
                    
                    person.childrenIds = Array.isArray(person.children_ids) ? person.children_ids.map(id => parseInt(id)) : [];
                    person.parentIds = Array.isArray(person.parent_ids) ? person.parent_ids.map(id => parseInt(id)) : [];

                    familyData.set(person.id, person);
                });

                console.log('Datos cargados en familyData (con IDs parseados):', familyData);
                
                const urlParams = new URLSearchParams(window.location.search);
                const idFromUrl = urlParams.get('personId');

                // Lógica de carga y selección de la persona principal para el árbol
                if (idFromUrl && familyData.has(parseInt(idFromUrl))) {
                    selectedPersonId = parseInt(idFromUrl); 
                } else if (familyData.size > 0) {
                    if (familyData.has(1)) { 
                        selectedPersonId = 1; // Priorizar ID 1 si existe
                    } else { 
                        selectedPersonId = Array.from(familyData.keys())[0]; // Tomar la primera persona si no hay ID 1
                    }
                } else {
                    selectedPersonId = null; // No hay personas en la base de datos
                }

                renderTree(); // Llama a renderTree después de decidir la persona principal
                
                if (selectedPersonId) {
                    showPersonDetails(selectedPersonId);
                } else {
                    document.getElementById('details-content').innerHTML = '<p class="text-gray-500">No hay datos en el árbol. ¡Añade la primera persona!</p>';
                    document.getElementById('edit-buttons').classList.add('hidden');
                }

            } catch (error) {
                console.error('Error al cargar los datos de la familia:', error);
                document.getElementById('details-content').innerHTML = '<p class="text-red-500">Error al cargar los datos. Intenta de nuevo más tarde.</p>';
            }
        }

        async function sendDataToAPI(actionData) {
            try {
                const response = await fetch(API_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(actionData),
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`HTTP error! status: ${response.status}, message: ${errorText}`);
                }

                const result = await response.json();
                if (result.success) {
                    console.log('Operación exitosa:', result.message);
                    await loadFamilyData(); 
                    return result; 
                } else {
                    console.error('Error en la operación en la base de datos:', result.message);
                    alert('Error al guardar: ' + result.message + (result.error ? `\nDetalles: ${result.error}` : ''));
                    return null;
                }
            } catch (error) {
                console.error('Error de red o servidor al guardar:', error);
                alert('Error de conexión o servidor al guardar los datos.');
                return null;
            }
        }

        // Función auxiliar para obtener todos los ancestros de una persona y su distancia generacional
        // Retorna un Map<personId, distance> donde distance es 0 para la persona original, 1 para padres, etc.
        function getAncestorsWithDistance(personId) {
            const ancestors = new Map(); // Map<id, distance>
            let queue = [{id: personId, dist: 0}];
            let head = 0;

            while(head < queue.length) {
                const { id: currentId, dist: currentDist } = queue[head++];
                // Si ya lo visitamos, solo actualiza si encontramos un camino más corto
                if (ancestors.has(currentId) && ancestors.get(currentId) <= currentDist) {
                    continue; 
                }
                ancestors.set(currentId, currentDist);

                const person = familyData.get(currentId);
                if (person && person.parentIds) {
                    person.parentIds.forEach(parentId => {
                        // Solo añadir si el padre existe en los datos cargados y no se ha visitado o se encontró a mayor distancia
                        if (familyData.has(parentId) && (!ancestors.has(parentId) || ancestors.get(parentId) > currentDist + 1)) {
                            queue.push({id: parentId, dist: currentDist + 1});
                        }
                    });
                }
            }
            return ancestors;
        }

        // Función auxiliar para obtener todos los descendientes de una persona y su distancia generacional
        // Retorna un Map<personId, distance> donde distance es 0 para la persona original, 1 para hijos, etc.
        function getDescendantsWithDistance(personId) {
            const descendants = new Map(); // Map<id, distance>
            let queue = [{id: personId, dist: 0}];
            let head = 0;

            while(head < queue.length) {
                const { id: currentId, dist: currentDist } = queue[head++];
                // Si ya lo visitamos, solo actualiza si encontramos un camino más corto
                if (descendants.has(currentId) && descendants.get(currentId) <= currentDist) {
                    continue; 
                }
                descendants.set(currentId, currentDist);

                const person = familyData.get(currentId);
                // Necesitamos encontrar personas que tengan a 'currentId' como uno de sus padres
                const children = Array.from(familyData.values()).filter(p => p.parentIds && p.parentIds.includes(currentId));

                children.forEach(child => {
                    // Solo añadir si el hijo existe y no se ha visitado o se encontró a mayor distancia
                    if (familyData.has(child.id) && (!descendants.has(child.id) || descendants.get(child.id) > currentDist + 1)) {
                        queue.push({id: child.id, dist: currentDist + 1});
                    }
                });
            }
            return descendants;
        }


        // --- INICIO DE CAMBIOS EN renderTree ---
        function renderTree() {
            const container = document.querySelector('.tree');
            if (!container) return;

            container.innerHTML = ''; 

            if (!selectedPersonId || !familyData.has(selectedPersonId)) {
                container.innerHTML = '<p class="text-gray-500 text-center">Selecciona una persona o agrega la primera para construir el árbol.</p>';
                return;
            }

            const centralPerson = familyData.get(selectedPersonId);
            let finalRootsToRender = new Set(); 

            // Obtener todos los ancestros de la persona central y sus distancias
            const centralAncestorsWithDist = getAncestorsWithDistance(selectedPersonId);

            // Identificar las raíces potenciales: personas que no tienen padres en la base de datos
            // PERO que son ancestros de la persona central (o la persona central misma).
            let currentPathQueue = [selectedPersonId];
            let processedForRootDiscovery = new Set();

            while(currentPathQueue.length > 0) {
                const currentId = currentPathQueue.shift();
                if (processedForRootDiscovery.has(currentId)) continue;
                processedForRootDiscovery.add(currentId);

                const currentPerson = familyData.get(currentId);
                if (!currentPerson) continue;

                // Si esta persona NO tiene padres cargados en familyData, es una raíz.
                let hasParentsInLoadedData = false;
                if (Array.isArray(currentPerson.parentIds) && currentPerson.parentIds.length > 0) {
                    hasParentsInLoadedData = currentPerson.parentIds.some(pId => familyData.has(pId));
                }

                if (!hasParentsInLoadedData) {
                    finalRootsToRender.add(currentPerson.id);
                } else {
                    // Si tiene padres, los añade para seguir subiendo en el camino
                    currentPerson.parentIds.forEach(pId => {
                        if (familyData.has(pId) && !processedForRootDiscovery.has(pId)) {
                            currentPathQueue.push(pId);
                        }
                    });
                }
                 // También considerar el cónyuge de la persona actual, si es parte de un ancestro común de la persona seleccionada
                if (currentPerson.spouseId && familyData.has(currentPerson.spouseId)) {
                    const spouse = familyData.get(currentPerson.spouseId);
                    if (spouse && spouse.spouseId === currentPerson.id && !processedForRootDiscovery.has(spouse.id)) {
                        // Si el cónyuge es una "raíz" (no tiene padres o sus padres no están en familyData)
                        let spouseHasParentsInLoadedData = false;
                        if (Array.isArray(spouse.parentIds) && spouse.parentIds.length > 0) {
                            spouseHasParentsInLoadedData = spouse.parentIds.some(pId => familyData.has(pId));
                        }
                        if (!spouseHasParentsInLoadedData) {
                             finalRootsToRender.add(spouse.id);
                        }
                        // No añadimos el cónyuge a currentPathQueue, porque solo rastreamos la ascendencia directa de la línea principal
                        // Los cónyuges se dibujarán como parte de sus parejas en generatePersonHtml.
                    }
                }
            }

            // Si por alguna razón no se encontró ninguna raíz (ej. persona aislada sin padres), usar la persona central.
            if (finalRootsToRender.size === 0) {
                finalRootsToRender.add(centralPerson.id);
            }
            
            // Convertir el Set de IDs a un array de objetos Persona y ordenar
            let displayRoots = Array.from(finalRootsToRender)
                                .map(id => familyData.get(id))
                                .filter(p => p !== undefined)
                                .sort((a,b) => a.id - b.id); 
            
            let treeHtmlContent = '';
            const renderedIdsForWholeTree = new Set(); 

            displayRoots.forEach(root => {
                treeHtmlContent += generatePersonHtml(root, renderedIdsForWholeTree);
            });

            container.innerHTML = '<ul>' + treeHtmlContent + '</ul>';
            addClickListeners(); 
            
            setTimeout(() => {
                const selectedMemberElement = document.querySelector(`.member[data-id="${selectedPersonId}"]`);
                if (selectedMemberElement) {
                    const treeContainer = document.getElementById('family-tree-container');
                    const offsetLeft = selectedMemberElement.offsetLeft - (treeContainer.offsetWidth / 2) + (selectedMemberElement.offsetWidth / 2);
                    treeContainer.scrollLeft = offsetLeft;

                    const offsetTop = selectedMemberElement.offsetTop - (treeContainer.offsetHeight / 3); 
                    treeContainer.scrollTop = offsetTop;
                }
            }, 100); 
        }
        // --- FIN DE CAMBIOS EN renderTree ---


        // Función auxiliar para obtener el ordinal para los grados de primos, tíos, etc.
        function getOrdinal(n) {
            const s = [" ", "Segundo", "Tercer", "Cuarto", "Quinto", "Sexto", "Séptimo", "Octavo", "Noveno", "Décimo"];
            if (n >= 1 && n <= s.length) {
                return s[n - 1];
            }
            return `${n}º`; 
        }


        // --- FUNCIÓN PRINCIPAL PARA CALCULAR LA RELACIÓN DINÁMICA ---
        function generatePersonHtml(person, renderedIds = new Set()) {
            if (!person || renderedIds.has(person.id)) return ''; 

            renderedIds.add(person.id); 

            let ageInTree = '';
            if (person.dob && person.dob !== '0000-00-00' && (!person.dod || person.dod === '0000-00-00')) {
                try {
                    const birthDate = new Date(person.dob);
                    const today = new Date();
                    if(!isNaN(birthDate.getTime())){
                        let ageDiff = today.getFullYear() - birthDate.getFullYear();
                        const m = today.getMonth() - birthDate.getMonth();
                        if (m < 0 || (m === 0 && today.getDate() < birthDate.getDate())) {
                            ageDiff--;
                        }
                        if (ageDiff >= 0) { 
                            ageInTree = `<div class="age">${ageDiff} años</div>`;
                        }
                    }
                } catch(e) { console.error("Error calculating age for tree node", e); }
            }

            let nodeContent = '<div class="node-content">';

            const getShortName = (fullName) => {
                if (!fullName) return '';
                const parts = fullName.split(' ').filter(part => part.trim() !== '');
                if (parts.length === 0) return '';
                
                let shortName = parts[0]; 
                if (parts.length > 1) {
                    let foundLastName = false;
                    for (let i = 1; i < parts.length; i++) {
                        if (parts[i].length > 2 || i === parts.length -1) { 
                            shortName += ' ' + parts[i];
                            foundLastName = true;
                            break;
                        }
                    }
                    if (!foundLastName && parts.length > 1) { 
                        shortName += ' ' + parts[1]; 
                    }
                }
                return shortName;
            };

            const getProfilePicHtml = (photoUrl, name) => {
                const defaultPhoto = 'https://placehold.co/60x60/E2E8F0/333333?text=Foto';
                if (photoUrl && photoUrl.trim() !== '') {
                    return `<img src="${photoUrl}" alt="Foto de ${name}" class="profile-pic" onerror="this.onerror=null;this.src='${defaultPhoto}';">`;
                }
                return `<img src="${defaultPhoto}" alt="Sin foto" class="profile-pic">`;
            };

            const calculateDynamicRelationship = (currentPersonId, referencePersonId) => {
                const currentPerson = familyData.get(currentPersonId);
                const referencePerson = familyData.get(referencePersonId);

                if (!currentPerson || !referencePerson) {
                    return 'Desconocido';
                }
                
                const currentIsMale = (currentPerson.gender === 'Masculino');
                const currentIsFemale = (currentPerson.gender === 'Femenino');


                // 0. La persona misma
                if (currentPersonId === referencePersonId) {
                    return 'Tú';
                }

                // 1. Cónyuge
                if (currentPerson.spouseId === referencePersonId && referencePerson.spouseId === currentPersonId) {
                    return 'Cónyuge';
                }

                // Caching de ancestros y descendientes para evitar recalcular
                const refAncestorsWithDist = getAncestorsWithDistance(referencePersonId);
                const refDescendantsWithDist = getDescendantsWithDistance(referencePersonId);
                const currentAncestorsWithDist = getAncestorsWithDistance(currentPersonId);
                const currentDescendantsWithDist = getDescendantsWithDistance(currentPersonId);


                // 2. Relaciones Directas Ascendentes (Padres, Abuelos, Bisabuelos, etc.) - De más específicas a menos
                const distToRefAnc = refAncestorsWithDist.get(currentPersonId);
                if (distToRefAnc !== undefined) {
                    if (distToRefAnc === 1) return currentIsMale ? 'Padre' : (currentIsFemale ? 'Madre' : 'Padre/Madre');
                    if (distToRefAnc === 2) return currentIsMale ? 'Abuelo' : (currentIsFemale ? 'Abuela' : 'Abuelo/a');
                    if (distToRefAnc === 3) return currentIsMale ? 'Bisabuelo' : (currentIsFemale ? 'Bisabuela' : 'Bisabuelo/a');
                    if (distToRefAnc === 4) return currentIsMale ? 'Tatarabuelo' : (currentIsFemale ? 'Tatarabuela' : 'Tatarabuelo/a');
                    if (distToRefAnc === 5) return currentIsMale ? 'Trastatarabuelo' : (currentIsFemale ? 'Trastatarabuela' : 'Trastatarabuelo/a');
                }

                // 3. Relaciones Directas Descendentes (Hijos, Nietos, Bisnietos, etc.) - De más específicas a menos
                const distToRefDesc = refDescendantsWithDist.get(currentPersonId);
                if (distToRefDesc !== undefined) {
                    if (distToRefDesc === 1) return currentIsMale ? 'Hijo' : (currentIsFemale ? 'Hija' : 'Hijo/a');
                    if (distToRefDesc === 2) return currentIsMale ? 'Nieto' : (currentIsFemale ? 'Nieta' : 'Nieto/a');
                    if (distToRefDesc === 3) return currentIsMale ? 'Bisnieto' : (currentIsFemale ? 'Bisnieta' : 'Bisnieto/a');
                    if (distToRefDesc === 4) return currentIsMale ? 'Tataranieto' : (currentIsFemale ? 'Tataranieta' : 'Tataranieto/a');
                    if (distToRefDesc === 5) return currentIsMale ? 'Trastataranieto' : (currentIsFemale ? 'Trastataranieta' : 'Trastataranieto/a');
                }

                // 4. Relaciones Colaterales - Hermanos
                // Son hermanos si comparten al menos un padre.
                if (currentPerson.parentIds && referencePerson.parentIds) {
                    const commonParents = currentPerson.parentIds.filter(pId => referencePerson.parentIds.includes(pId));
                    if (commonParents.length > 0 && currentPersonId !== referencePersonId) { // Asegurarse que no sea la misma persona
                        return currentIsMale ? 'Hermano' : (currentIsFemale ? 'Hermana' : 'Hermano/a');
                    }
                }
                
                // 5. Relaciones Políticas (Cuñados, Suegros, Nueras/Yernos, Abuelos Políticos)
                // Cuñados: hermanao de cónyuge
                if (referencePerson.spouseId && familyData.has(referencePerson.spouseId)) {
                    const refSpouse = familyData.get(referencePerson.spouseId);
                    if (refSpouse && currentPerson.parentIds && refSpouse.parentIds) {
                        const commonParentsWithSpouse = currentPerson.parentIds.filter(pId => refSpouse.parentIds.includes(pId));
                        if (commonParentsWithSpouse.length > 0 && currentPersonId !== refSpouse.id) { // No es el cónyuge mismo
                            return currentIsMale ? 'Cuñado' : (currentIsFemale ? 'Cuñada' : 'Cuñado/a');
                        }
                    }
                }

                // Suegros: padre del cónyuge de referencePerson
                if (referencePerson.spouseId && familyData.has(referencePerson.spouseId)) {
                    const refSpouse = familyData.get(referencePerson.spouseId);
                    if (refSpouse && refSpouse.parentIds && refSpouse.parentIds.includes(currentPersonId)) {
                        return currentIsMale ? 'Suegro' : (currentIsFemale ? 'Suegra' : 'Suegro/a');
                    }
                }
                // Abuelos Políticos: abuelo del cónyuge de referencePerson
                if (referencePerson.spouseId && familyData.has(referencePerson.spouseId)) {
                    const refSpouse = familyData.get(referencePerson.spouseId);
                    if (refSpouse) {
                        const refSpouseAncestors = getAncestorsWithDistance(refSpouse.id);
                        if (refSpouseAncestors.has(currentPersonId) && refSpouseAncestors.get(currentPersonId) === 2) {
                            return currentIsMale ? 'Abuelo Político' : (currentIsFemale ? 'Abuela Política' : 'Abuelo/a Político/a');
                        }
                    }
                }
                
                // Yerno/Nuera: cónyuge de hijo/hija de referencePerson
                if (referencePerson.childrenIds) {
                    for (const childId of referencePerson.childrenIds) {
                        const child = familyData.get(childId);
                        if (child && child.spouseId === currentPersonId && currentPerson.spouseId === child.id) {
                            return currentIsMale ? 'Yerno' : (currentIsFemale ? 'Nuera' : 'Yerno/Nuera');
                        }
                    }
                }

                // 6. Relaciones Colaterales con grados (Tíos, Sobrinos, Primos) - Se basa en el LCA
                let lowestCommonAncestorId = null;
                let minSumDistances = Infinity;

                // Encontrar el LCA entre currentPerson y referencePerson
                // Es importante que LCA no sea ni currentPerson ni referencePerson
                // (ya que esos casos se cubren con relaciones directas o cónyuge)
                for (let [idA, distA] of currentAncestorsWithDist.entries()) {
                    if (refAncestorsWithDist.has(idA)) {
                        const distB = refAncestorsWithDist.get(idA);
                        // Asegurarse de que el LCA no es la persona de referencia ni la persona actual
                        if (idA !== currentPersonId && idA !== referencePersonId) {
                            if (distA + distB < minSumDistances) {
                                minSumDistances = distA + distB;
                                lowestCommonAncestorId = idA;
                            }
                        }
                    }
                }
                
                if (lowestCommonAncestorId !== null) {
                    const distCurrentToLCA = currentAncestorsWithDist.get(lowestCommonAncestorId) || 0;
                    const distRefToLCA = refAncestorsWithDist.get(lowestCommonAncestorId) || 0;

                    // El grado colateral es la distancia a la que ambos están del LCA, menos 1 (porque el LCA es el "Tronco" común).
                    // Si distancias al LCA son (X, Y)
                    // Grado colateral = min(X, Y)
                    // Diferencia generacional = |X - Y|

                    // Para Tíos y Sobrinos (línea directa de un hermano del ancestro)
                    // Si el LCA es un padre de A (distancia 1) y de B (distancia > 1)
                    if (distCurrentToLCA === 1 && distRefToLCA > 1) { // CurrentPerson es hermano del padre del ReferencePerson
                        return currentIsMale ? 'Tío' : (currentIsFemale ? 'Tía' : 'Tío/a');
                    }
                    if (distRefToLCA === 1 && distCurrentToLCA > 1) { // ReferencePerson es hermano del padre del CurrentPerson
                        return currentIsMale ? 'Sobrino' : (currentIsFemale ? 'Sobrina' : 'Sobrino/a');
                    }
                    
                    // Primos: misma distancia del LCA
                    if (distCurrentToLCA === distRefToLCA && distCurrentToLCA > 1) {
                        const degree = distCurrentToLCA - 1; // Grado del primo (Primo, Primo Segundo, etc.)
                        return currentIsMale ? `Primo ${getOrdinal(degree)}` : (currentIsFemale ? `Prima ${getOrdinal(degree)}` : `Primo/a ${getOrdinal(degree)}`);
                    }

                    // Tíos Abuelos, Sobrinos Nietos, etc. (cuando LCA es más arriba)
                    // CurrentPerson es más ancestro que referencePerson respecto al LCA
                    if (distCurrentToLCA < distRefToLCA) {
                        const collateralDegree = distCurrentToLCA - 1; // Distancia a la que se separan de la línea directa del LCA
                        const generationalDiff = distRefToLCA - distCurrentToLCA; // Cuántas generaciones de diferencia

                        if (generationalDiff === 1) { // Padres hermanos de padres
                            return currentIsMale ? 'Tío Abuelo' : (currentIsFemale ? 'Tía Abuela' : 'Tío/a Abuelo/a');
                        }
                        if (generationalDiff === 2) {
                            return currentIsMale ? 'Tío Bisabuelo' : (currentIsFemale ? 'Tía Bisabuela' : 'Tío/a Bisabuelo/a');
                        }
                         if (generationalDiff === 3) {
                            return currentIsMale ? 'Tío Tatarabuelo' : (currentIsFemale ? 'Tía Tatarabuela' : 'Tío/a Tatarabuelo/a');
                        }
                    } 
                    // CurrentPerson es más joven que referencePerson respecto al LCA
                    else if (distCurrentToLCA > distRefToLCA) {
                        const collateralDegree = distRefToLCA - 1;
                        const generationalDiff = distCurrentToLCA - distRefToLCA;

                        if (generationalDiff === 1) { // Hijos de sobrinos
                            return currentIsMale ? 'Sobrino Nieto' : (currentIsFemale ? 'Sobrina Nieta' : 'Sobrino/a Nieto/a');
                        }
                        if (generationalDiff === 2) {
                            return currentIsMale ? 'Sobrino Bisnieto' : (currentIsFemale ? 'Sobrina Bisnieta' : 'Sobrino/a Bisnieto/a');
                        }
                         if (generationalDiff === 3) {
                            return currentIsMale ? 'Sobrino Tataranieto' : (currentIsFemale ? 'Sobrina Tataranieta' : 'Sobrino/a Tataranieto/a');
                        }
                    }
                }
                
                // Fallback a la relación de la DB si no se encuentra algo específico, o 'Familiar'
                return currentPerson.relationship || 'Familiar';
            };
            // --- FIN FUNCIÓN DE CALCULAR RELACIÓN DINÁMICA ---

            const displayRelationship = calculateDynamicRelationship(person.id, selectedPersonId);
            const mainPersonShortName = getShortName(person.name);
            const mainPersonProfilePic = getProfilePicHtml(person.photo, person.name);
            const mainPersonHtml = `
                <div class="member" data-id="${person.id}">
                    ${mainPersonProfilePic}
                    <div class="name">${mainPersonShortName}</div>
                    <div class="relationship">${displayRelationship}</div>
                    ${ageInTree}
                </div>
            `;

            // Lógica para el cónyuge
            if (person.spouseId && familyData.has(person.spouseId)) {
                const spouse = familyData.get(person.spouseId);
                // Solo si el vínculo es bidireccional y el cónyuge no ha sido renderizado ya
                if (spouse && spouse.id !== person.id && spouse.spouseId === person.id && !renderedIds.has(spouse.id)) { 
                    renderedIds.add(spouse.id); 
                    
                    let spouseAgeInTree = '';
                    if (spouse.dob && spouse.dob !== '0000-00-00' && (!spouse.dod || spouse.dod === '0000-00-00')) {
                        try {
                            const birthDate = new Date(spouse.dob);
                            const today = new Date();
                            if(!isNaN(birthDate.getTime())){
                                let ageDiff = today.getFullYear() - birthDate.getFullYear();
                                const m = today.getMonth() - birthDate.getMonth();
                                if (m < 0 || (m === 0 && today.getDate() < birthDate.getDate())) {
                                    ageDiff--;
                                }
                                if (ageDiff >= 0) {
                                    spouseAgeInTree = `<div class="age">${ageDiff} años</div>`;
                                }
                            }
                        } catch(e) { console.error("Error calculating spouse age for tree node", e); }
                    }

                    const spouseDisplayRelationship = calculateDynamicRelationship(spouse.id, selectedPersonId);
                    const spouseShortName = getShortName(spouse.name);
                    const spouseProfilePic = getProfilePicHtml(spouse.photo, spouse.name);
                    const spouseHtml = `
                        <div class="member" data-id="${spouse.id}">
                            ${spouseProfilePic}
                            <div class="name">${spouseShortName}</div>
                            <div class="relationship">${spouseDisplayRelationship}</div>
                            ${spouseAgeInTree}
                        </div>
                    `;
                    const spouseLine = '<div class="spouse-line"></div>';

                    if (person.id < spouse.id) {
                        nodeContent += mainPersonHtml + spouseLine + spouseHtml;
                    } else {
                        nodeContent += spouseHtml + spouseLine + mainPersonHtml;
                    }
                } else {
                    nodeContent += mainPersonHtml; 
                }
            } else {
                nodeContent += mainPersonHtml;
            }
            nodeContent += '</div>';

            let childrenHtml = '';
            
            const parentIdsOfCurrentUnit = new Set();
            parentIdsOfCurrentUnit.add(person.id);
            if (person.spouseId && familyData.has(person.spouseId) && familyData.get(person.spouseId).spouseId === person.id) {
                parentIdsOfCurrentUnit.add(person.spouseId);
            }

            const childrenOfThisFamilyUnit = Array.from(familyData.values())
                                                .filter(child => {
                                                    const childParents = child.parentIds || [];
                                                    return Array.from(parentIdsOfCurrentUnit).some(pId => childParents.includes(pId));
                                                })
                                                .filter(child => !renderedIds.has(child.id))
                                                .sort((a,b) => a.name.localeCompare(b.name));

            if (childrenOfThisFamilyUnit.length > 0) {
                childrenHtml += '<ul>';
                childrenOfThisFamilyUnit.forEach(child => {
                    childrenHtml += generatePersonHtml(child, renderedIds); 
                });
                childrenHtml += '</ul>';
            }

            return `<li>${nodeContent}${childrenHtml}</li>`;
        }


        function showPersonDetails(personId) {
            selectedPersonId = personId; 
            const person = familyData.get(personId);
            const detailsContent = document.getElementById('details-content');
            const editButtons = document.getElementById('edit-buttons');
            const editPersonLink = document.getElementById('edit-person-link');

            if (!person || !detailsContent || !editButtons || !editPersonLink) {
                detailsContent.innerHTML = '<p class="text-gray-500">Selecciona una persona para ver su información.</p>';
                editButtons.classList.add('hidden');
                editPersonLink.href = '#'; 
                return;
            }
            
            renderTree(); 

            document.querySelectorAll('.member').forEach(el => el.classList.remove('selected', 'highlighted', 'ancestor-spouse-highlight'));
            document.querySelectorAll('.tree li').forEach(li => li.classList.remove('highlighted-path'));
            document.querySelectorAll('.node-content').forEach(nc => nc.classList.remove('highlighted-path'));

            const currentSelectedMemberElement = document.querySelector(`.member[data-id="${personId}"]`);
            if(currentSelectedMemberElement) {
                currentSelectedMemberElement.classList.add('selected');
            }

            let queue = [personId]; 
            const visitedForHighlight = new Set(); 

            while (queue.length > 0) {
                const currentId = queue.shift(); 
                
                if (visitedForHighlight.has(currentId)) {
                    continue; 
                }
                visitedForHighlight.add(currentId); 

                const currentPerson = familyData.get(currentId);
                if (!currentPerson) {
                    continue; 
                }

                const memberElement = document.querySelector(`.member[data-id="${currentPerson.id}"]`);
                if (memberElement) {
                    memberElement.classList.add('highlighted');
                }

                if (currentPerson.spouseId && familyData.has(currentPerson.spouseId)) {
                    const spouse = familyData.get(currentPerson.spouseId);
                    if (spouse && spouse.spouseId === currentPerson.id) { 
                        const spouseElement = document.querySelector(`.member[data-id="${currentPerson.spouseId}"]`);
                        if (spouseElement) {
                            spouseElement.classList.add('ancestor-spouse-highlight');
                        }
                        const nodeContentElement = memberElement ? memberElement.closest('.node-content') : null;
                        if (nodeContentElement) {
                            nodeContentElement.classList.add('highlighted-path');
                        }
                    }
                }
                
                const liElement = memberElement ? memberElement.closest('li') : null;
                if (liElement) {
                    liElement.classList.add('highlighted-path');
                }

                const parentsOfCurrentPerson = Array.from(familyData.values())
                    .filter(p => p.childrenIds && p.childrenIds.includes(currentId));

                parentsOfCurrentPerson.forEach(parent => {
                    if (!visitedForHighlight.has(parent.id) && familyData.has(parent.id)) {
                        queue.push(parent.id);
                    }
                });
            }


            let age = '';
            let ageAtDeath = '';
            if(person.dob){
                try {
                    const birthDate = new Date(person.dob);
                    const endDate = person.dod && person.dod !== '0000-00-00' ? new Date(person.dod) : new Date();
                    if(!isNaN(birthDate.getTime())){
                        let ageDiff = endDate.getFullYear() - birthDate.getFullYear();
                        const m = endDate.getMonth() - birthDate.getMonth();
                        if (m < 0 || (m === 0 && today.getDate() < birthDate.getDate())) {
                            ageDiff--;
                        }
                        if(person.dod && person.dod !== '0000-00-00') {
                            ageAtDeath = `(falleció a los ${ageDiff} años)`;
                        } else if (ageDiff >= 0) { 
                            age = `${ageDiff} años`;
                        }
                    }
                } catch(e) { console.error("Error calculating age", e); }
            }
            
            const formatDate = (dateString) => {
                if (!dateString || dateString === '0000-00-00') return 'No disponible';
                try {
                    const date = new Date(dateString);
                    const adjustedDate = new Date(date.getTime() + date.getTimezoneOffset() * 60000); 
                    if(isNaN(adjustedDate.getTime())) return 'Fecha inválida';
                    const options = { year: 'numeric', month: 'long', day: 'numeric' };
                    return adjustedDate.toLocaleDateString('es-ES', options);
                } catch(e) {
                    return 'Fecha inválida';
                }
            };

            detailsContent.innerHTML = `
                <img src="${person.photo || 'https://placehold.co/120x120/E2E8F0/333333?text=Foto'}" alt="Foto de ${person.name}" class="w-24 h-24 md:w-32 md:h-32 rounded-full mx-auto mb-4 object-cover border-4 border-white shadow-md" onerror="this.onerror=null;this.src='https://placehold.co/120x120/E2E8F0/333333?text=Foto';">
                <h3 class="text-xl font-bold">${person.name}</h3>
                <p class="text-sm text-gray-500 mb-4">${person.relationship || ''}</p>
                <div class="text-left space-y-2">
                    <p><strong>Género:</strong> ${person.gender || 'No disponible'}</p>
                    <p><strong>RUT:</strong> ${person.rut || 'No disponible'}</p>
                    <p><strong>Nacimiento:</strong> ${formatDate(person.dob)}</p>
                    ${age ? `<p><strong>Edad:</strong> ${age}</p>` : ''}
                    <p><strong>Matrimonio:</strong> ${formatDate(person.dom)}</p>
                    <p><strong>Fallecimiento:</strong> ${formatDate(person.dod)} ${ageAtDeath}</p>
                </div>
            `;
            editButtons.classList.remove('hidden');

            editPersonLink.href = `editar.php?id=${personId}`;
        }

        const modal = document.getElementById('person-modal');
        const form = document.getElementById('person-form');
        const cancelBtn = document.getElementById('cancel-btn');
        const relationshipsModal = document.getElementById('relationships-modal');
        const relationshipPersonNameSpan = document.getElementById('relationship-person-name');
        const currentSpouseDisplay = document.getElementById('current-spouse-display');
        const currentParentsList = document.getElementById('current-parents-list');
        const currentChildrenList = document.getElementById('current-children-list');
        const addNewSpouseBtn = document.getElementById('add-new-spouse-btn'); 
        const linkExistingSpouseBtn = document.getElementById('link-existing-spouse-btn');
        const addNewParentBtn = document.getElementById('add-new-parent-btn'); 
        const linkExistingParentBtn = document.getElementById('link-existing-parent-btn');
        const addNewChildBtn = document.getElementById('add-new-child-btn'); 
        const linkExistingChildBtn = document.getElementById('link-existing-child-btn');

        const closeRelationshipsModalBtn = document.getElementById('close-relationships-modal-btn');

        const selectPersonModal = document.getElementById('select-person-modal');
        const selectModalTitle = document.getElementById('select-modal-title');
        const personSearchInput = document.getElementById('person-search-input');
        const personListContainer = document.getElementById('person-list-container');
        const cancelSelectPersonBtn = document.getElementById('cancel-select-person-btn');


        function openPersonModal(mode, personId = null) {
            modalMode = mode; 
            relatedPersonId = personId; 
            relatedPersonSpouseId = null; 
            
            const formTitle = document.getElementById('modal-title');
            const personIdField = form.querySelector('#person-id'); 

            form.reset();
            personIdField.value = ''; 

            if (mode.startsWith('add_') && personId !== null) {
                const selectedPerson = familyData.get(personId);
                if (!selectedPerson) return; 
                relatedPersonSpouseId = selectedPerson.spouseId; 
                
                if (mode === 'add_descendant') {
                    formTitle.innerText = `Agregar Hijo/a a ${selectedPerson.name}`;
                    form.querySelector('#relationship').value = 'Hijo/a'; 
                } else if (mode === 'add_ancestor') {
                    formTitle.innerText = `Agregar Padre/Madre a ${selectedPerson.name}`;
                    form.querySelector('#relationship').value = 'Padre/Madre'; 
                } else if (mode === 'add_spouse') {
                    formTitle.innerText = `Agregar Cónyuge a ${selectedPerson.name}`;
                    form.querySelector('#relationship').value = 'Cónyuge'; 
                }
            }
            
            modal.classList.remove('hidden');
        }

        async function openRelationshipsModal(personId) {
            selectedPersonId = personId; 
            const person = familyData.get(personId);
            if (!person) return;

            relationshipPersonNameSpan.innerText = person.name;

            currentSpouseDisplay.innerHTML = '';
            currentParentsList.innerHTML = '';
            currentChildrenList.innerHTML = '';

            if (person.spouseId && familyData.has(person.spouseId)) {
                const spouse = familyData.get(person.spouseId);
                if (spouse.spouseId === person.id) {
                    currentSpouseDisplay.innerHTML = `
                        <span class="font-semibold">${spouse.name}</span>
                        <button class="remove-relationship-btn text-red-500 hover:text-red-700 text-sm" 
                                data-action="remove_spouse" 
                                data-person-id="${person.id}">Eliminar Vínculo</button>
                    `;
                } else {
                    currentSpouseDisplay.innerHTML = '<p class="text-gray-500">No hay cónyuge recíproco asignado.</p>';
                }
            } else {
                currentSpouseDisplay.innerHTML = '<p class="text-gray-500">No hay cónyuge asignado.</p>';
            }

            if (person.parentIds && person.parentIds.length > 0) {
                person.parentIds.sort((a,b) => familyData.get(a)?.name.localeCompare(familyData.get(b)?.name) || 0).forEach(parentId => {
                    const parent = familyData.get(parentId);
                    if (parent) {
                        const div = document.createElement('div');
                        div.className = 'flex items-center justify-between p-2 bg-gray-100 rounded-md border border-gray-200';
                        div.innerHTML = `
                            <span class="font-semibold">${parent.name}</span>
                            <button class="remove-relationship-btn text-red-500 hover:text-red-700 text-sm" 
                                    data-action="remove_parent_child" 
                                    data-parent-id="${parentId}" 
                                    data-child-id="${person.id}">Eliminar Vínculo</button>
                        `;
                        currentParentsList.appendChild(div);
                    }
                });
            } else {
                currentParentsList.innerHTML = '<p class="text-gray-500">No hay padres asignados.</p>';
            }

            let childrenOfThisPersonAndSpouse = new Set();
            if (person.childrenIds) {
                person.childrenIds.forEach(childId => childrenOfThisPersonAndSpouse.add(childId));
            }
            if (person.spouseId && familyData.has(person.spouseId) && familyData.get(person.spouseId).spouseId === person.id) {
                const spouse = familyData.get(person.spouseId);
                if (spouse.childrenIds) {
                    spouse.childrenIds.forEach(childId => childrenOfThisPersonAndSpouse.add(childId));
                }
            }

            const childrenToShow = Array.from(childrenOfThisPersonAndSpouse)
                                        .map(id => familyData.get(id))
                                        .filter(child => child !== undefined) 
                                        .filter(child => {
                                            const childParents = child.parentIds || [];
                                            const isChildOfThisPerson = childParents.includes(person.id);
                                            
                                            let isChildOfSpouse = false;
                                            if (person.spouseId && familyData.has(person.spouseId) && familyData.get(person.spouseId).spouseId === person.id) {
                                                isChildOfSpouse = childParents.includes(person.spouseId);
                                            }
                                            return isChildOfThisPerson || isChildOfSpouse;
                                        })
                                        .sort((a,b) => a.name.localeCompare(b.name));
            
            if (childrenToShow.length > 0) {
                currentChildrenList.innerHTML = ''; 
                childrenToShow.forEach(child => {
                    const div = document.createElement('div');
                    div.className = 'flex items-center justify-between p-2 bg-gray-100 rounded-md border border-gray-200';
                    div.innerHTML = `
                        <span class="font-semibold">${child.name}</span>
                        <button class="remove-relationship-btn text-red-500 hover:text-red-700 text-sm" 
                                data-action="remove_parent_child" 
                                data-parent-id="${person.id}" 
                                data-child-id="${child.id}">Eliminar Vínculo</button>
                    `;
                    currentChildrenList.appendChild(div);
                });
            } else {
                 currentChildrenList.innerHTML = '<p class="text-gray-500">No hay hijos/as asignados.</p>';
            }

            relationshipsModal.classList.remove('hidden');
        }

         function openSelectPersonModal(mode, currentPersonId) {
            selectPersonMode = mode;
            personToLinkToId = currentPersonId; 

            if (mode === 'link_spouse') {
                selectModalTitle.innerText = `Seleccionar Cónyuge para ${familyData.get(currentPersonId)?.name}`;
            } else if (mode === 'link_parent') {
                selectModalTitle.innerText = `Seleccionar Padre/Madre para ${familyData.get(currentPersonId)?.name}`;
            } else if (mode === 'link_child') {
                selectModalTitle.innerText = `Seleccionar Hijo/a para ${familyData.get(currentPersonId)?.name}`;
            }

            renderSelectablePeopleList(personSearchInput.value, currentPersonId); 
            personSearchInput.value = ''; 
            personSearchInput.focus();

            selectPersonModal.classList.remove('hidden');
        }

        function renderSelectablePeopleList(searchTerm = '', excludeId = null) {
            personListContainer.innerHTML = '';
            const filteredPeople = Array.from(familyData.values()).filter(p => 
                p.id !== excludeId && 
                p.name.toLowerCase().includes(searchTerm.toLowerCase())
            ).sort((a,b) => a.name.localeCompare(b.name));

            if (filteredPeople.length === 0) {
                personListContainer.innerHTML = '<p class="p-3 text-gray-500 text-center">No se encontraron personas.</p>';
                return;
            }

            filteredPeople.forEach(person => {
                const div = document.createElement('div');
                div.className = 'p-3 border-b border-gray-100 cursor-pointer hover:bg-blue-50 transition duration-150';
                div.dataset.personId = person.id; 
                div.innerText = `${person.name} (${person.relationship || 'sin relación'})`;
                personListContainer.appendChild(div);
            });
        }
        
        document.getElementById('manage-relationships-btn').addEventListener('click', () => {
            if (selectedPersonId) {
                openRelationshipsModal(selectedPersonId);
            } else {
                alert('Selecciona una persona para gestionar sus relaciones.');
            }
        });

        closeRelationshipsModalBtn.addEventListener('click', () => {
            relationshipsModal.classList.add('hidden');
            if (selectedPersonId) {
                showPersonDetails(selectedPersonId);
            }
            loadFamilyData(); 
        });

        addNewSpouseBtn.addEventListener('click', () => {
            if (selectedPersonId) {
                relationshipsModal.classList.add('hidden'); 
                openPersonModal('add_spouse', selectedPersonId); 
            }
        });

        addNewParentBtn.addEventListener('click', () => {
           if (selectedPersonId) {
                relationshipsModal.classList.add('hidden'); 
                openPersonModal('add_ancestor', selectedPersonId); 
            }
        });

        addNewChildBtn.addEventListener('click', () => {
            if (selectedPersonId) {
                relationshipsModal.classList.add('hidden'); 
                openPersonModal('add_descendant', selectedPersonId); 
            }
        });

        linkExistingSpouseBtn.addEventListener('click', () => {
            if (selectedPersonId) {
                openSelectPersonModal('link_spouse', selectedPersonId);
            }
        });

        linkExistingParentBtn.addEventListener('click', () => {
            if (selectedPersonId) {
                openSelectPersonModal('link_parent', selectedPersonId); 
            }
        });

        linkExistingChildBtn.addEventListener('click', () => {
            if (selectedPersonId) {
                openSelectPersonModal('link_child', selectedPersonId); 
            }
        });

        relationshipsModal.addEventListener('click', async (event) => {
            if (event.target.classList.contains('remove-relationship-btn')) {
                const button = event.target;
                const action = button.dataset.action;
                let dataToSend = { _action: action };

                if (action === 'remove_parent_child') {
                    dataToSend.parent_id = parseInt(button.dataset.parentId);
                    dataToSend.child_id = parseInt(button.dataset.childId);
                    if (!confirm(`¿Estás seguro de que quieres eliminar el vínculo de padre/madre entre ${familyData.get(dataToSend.parent_id)?.name} y ${familyData.get(dataToSend.child_id)?.name}?`)) {
                        return;
                    }
                } else if (action === 'remove_spouse') {
                    dataToSend.person_id = parseInt(button.dataset.personId);
                    if (!confirm(`¿Estás seguro de que quieres eliminar el vínculo de cónyuge de ${familyData.get(dataToSend.person_id)?.name}? Esto también desvinculará a su cónyuge.`)) {
                        return;
                    }
                } else {
                    return; 
                }

                const result = await sendDataToAPI(dataToSend);
                if (result && result.success) {
                    openRelationshipsModal(selectedPersonId); 
                    loadFamilyData();
                }
            }
        });

        
        form.addEventListener('submit', async (event) => {
            event.preventDefault();

            const personData = {
                name: form.querySelector('#name').value,
                relationship: form.querySelector('#relationship').value,
                rut: form.querySelector('#rut').value,
                gender: form.querySelector('#gender').value,
                dob: form.querySelector('#dob').value,
                dom: form.querySelector('#dom').value,
                dod: form.querySelector('#dod').value,
                photo: form.querySelector('#photo').value,
            };

            let actionData = { _action: modalMode, personData: personData };

            actionData.selectedPersonId = relatedPersonId;
            if (modalMode === 'add_descendant') {
                actionData.selectedPersonSpouseId = relatedPersonSpouseId;
            }

            const result = await sendDataToAPI(actionData);
            if (result && result.success) {
                modal.classList.add('hidden');
                if (result.new_person_id) { 
                    showPersonDetails(result.new_person_id);
                } else if (relatedPersonId) {
                    showPersonDetails(relatedPersonId);
                }
            }
        });

        cancelBtn.addEventListener('click', () => {
             modal.classList.add('hidden');
             if (relationshipsModal.classList.contains('hidden') && selectedPersonId) {
                 openRelationshipsModal(selectedPersonId);
             }
        });

        personSearchInput.addEventListener('input', (event) => {
            renderSelectablePeopleList(event.target.value, personToLinkToId); 
        });

        personListContainer.addEventListener('click', async (event) => {
            const selectedElement = event.target.closest('div[data-person-id]');
            if (selectedElement) {
                const targetPersonId = parseInt(selectedElement.dataset.personId);
                let dataToSend = {};

                if (selectPersonMode === 'link_spouse') {
                    dataToSend = {
                        _action: 'link_existing_spouse',
                        person1_id: personToLinkToId,
                        person2_id: targetPersonId
                    };
                } else if (selectPersonMode === 'link_parent') {
                    dataToSend = {
                        _action: 'link_existing_parent_child',
                        parent_id: targetPersonId, 
                        child_id: personToLinkToId 
                    };
                } else if (selectPersonMode === 'link_child') {
                    dataToSend = {
                        _action: 'link_existing_parent_child',
                        parent_id: personToLinkToId, 
                        child_id: targetPersonId 
                    };
                }

                const result = await sendDataToAPI(dataToSend);
                if (result && result.success) {
                    selectPersonModal.classList.add('hidden');
                    relationshipsModal.classList.add('hidden'); 
                    showPersonDetails(selectedPersonId); 
                    loadFamilyData(); 
                }
            }
        });

        cancelSelectPersonBtn.addEventListener('click', () => {
            selectPersonModal.classList.add('hidden');
            if (selectedPersonId) {
                openRelationshipsModal(selectedPersonId);
            }
        });

        document.getElementById('add-descendant-btn').addEventListener('click', () => {
            if (selectedPersonId) {
                openPersonModal('add_descendant', selectedPersonId);
            }
        });

        document.getElementById('add-ancestor-btn').addEventListener('click', () => {
            if (selectedPersonId) {
                openPersonModal('add_ancestor', selectedPersonId);
            }
        });

        function addClickListeners() {
            document.querySelectorAll('.member').forEach(element => {
                element.addEventListener('click', (event) => {
                    event.stopPropagation();
                    const personId = parseInt(event.currentTarget.dataset.id);
                    showPersonDetails(personId);
                });
            });
        }
        
        document.addEventListener('DOMContentLoaded', () => {
            loadFamilyData();
        });

    </script>
</body>
</html>